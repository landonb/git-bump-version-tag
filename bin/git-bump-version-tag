#!/usr/bin/env bash
# vim:tw=0:ts=2:sw=2:et:norl:ft=bash
# Author: Landon Bouma (landonb &#x40; retrosoft &#x2E; com)
# Project: https://github.com/landonb/git-bump-version-tag#üê´
# Copyright ¬© 2020 Landon Bouma. All rights reserved.
# License: MIT. Please find more in the LICENSE file.

# FIXME/2020-07-01: Handle this error better: If there's no tracking branch,
# you'll see, e.g.,
#   $ git bump p
#   fatal: ambiguous argument '@{u}': unknown revision or path not in the working tree.
#   Use '--' to separate paths from revisions, like this:
#   'git <command> [<revision>...] -- [<file>...]'
#   ALERT: No remote named ‚Äú@{u}‚Äù
#   Please Yes/no/skip: Okay to bump ‚Äú1.0.2‚Äù ‚Üí ‚Äú1.0.3‚Äù? [Y/n/s]
#   ERROR: No remote named ‚Äú@{u}‚Äù
# The current work-around is to set a tracking branch, e.g.,:
#   $ git pr -u
#   Branch 'release' set up to track remote branch 'release' from 'release'.
#   Everything up-to-date
#   $ git bump p
#   Please Yes/no/skip: Okay to bump ‚Äú1.0.3‚Äù ‚Üí ‚Äú1.0.4‚Äù? [Y/n/s]
# Except when I create a new branch to test, I get a different error, e.g.,
#   $ git co -b test
#   Switched to a new branch 'test'
#   $ git bump s
#   fatal: no upstream configured for branch 'test'
#   ALERT: No remote named ‚Äúorigin‚Äù
#   ERROR: No remote named ‚Äúorigin‚Äù
# Which is actually what I'd expect. So I'm not quite sure how I triggered
# the first error I mentioned.

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

# YOU: Uncomment (or set from environment) for a dry run:
#  DRY_RUN=true
DRY_RUN=${DRY_RUN:-false}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

source_deps () {
  # Ensure coreutils installed (from Linux pkg. mgr., or from macOS Homebrew).
  insist_cmd 'realpath'

  # Ensure pep440cmp installed.
  # https://github.com/hotoffthehamster/pep440-version-compare-cli
  insist_cmd 'pep440cmp'

  # Load ask_yesnoskip.
  # https://github.com/landonb/sh-ask-yesnoskip
  . "$(dirname "$(realpath "$0")")/../deps/sh-ask-yesnoskip/bin/ask-yesnoskip.sh"

  # Load git_* functions, including
  #   git_branch_name
  #   git_insist_git_repo
  #   git_insist_pristine
  #   git_latest_version_tag
  #   git_remote_exists
  #   git_versions_tagged_for_commit
  #   github_purge_release_and_tags_of_same_name;
  # and load environs, including GITSMART_RE_VERSPARTS.
  # https://github.com/landonb/sh-git-nubs
  . "$(dirname "$(realpath "$0")")/../deps/sh-git-nubs/bin/git-nubs.sh"
}

insist_cmd () {
  local cmdname="$1"

  command -v "${cmdname}" > /dev/null && return

  >&2 echo "ERROR: Missing system command ‚Äò${cmdname}‚Äô."

  exit 1
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

git_branch_head_version () {
  commits_vtags="$(git_versions_tagged_for_commit)"

  [ -z "${commits_vtags}" ] && return

  local n_tags=$(echo "${commits_vtags}" | wc -l)

  if [ "${n_tags}" -ne 1 ]; then
    >&2 echo "ERROR: Expected no more than 1 but found ${n_tags} version tags on HEAD."
    exit 1
  fi

  echo -n "${commits_vtags}"
}

must_head_unversioned_or_matching () {
  local headvers="$1"
  local curr_version="$2"
  local remote_name="$3"

  [ -z "${headvers}" ] && return

  [ "${headvers}" = "${curr_version}" ] && return

  # MAYBE/2020-03-23 21:50: Allow this use case?
  # - And do what? Replace tag with different version?
  # Seems like an unlikely use case, actually.
  >&2 echo "ERROR: HEAD already version-tagged ‚Äú${headvers}‚Äù"
  #>&2 echo

  print_tag_delete_hints "${headvers}" "${remote_name}"

  exit 1
}

print_tag_delete_hints () {
  local headvers="$1"
  local remote_name="$2"

  >&2 echo "- To delete the local tag, try:"
  #>&2 echo
  >&2 echo "    git tag --delete ${headvers}"
  #>&2 echo
  >&2 echo "- To delete the remote tag, try:"
  #>&2 echo
  >&2 echo "    git push ${remote_name} :refs/tags/${headvers}"
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

must_remote_exists () {
  local remote_name="$1"

  git_remote_exists "${remote_name}" && return

  >&2 echo "ERROR: No remote named ‚Äú${remote_name}‚Äù"

  exit 1
}

warn_remote_absent () {
  local remote_name="$1"

  git_remote_exists "${remote_name}" && return

  >&2 echo "ALERT: No remote named ‚Äú${remote_name}‚Äù"
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

latest_version_parts () {
  local curr_version="$1"

  declare -a partsarr

  partsarr=($(echo "${curr_version}" | /usr/bin/env sed -E "s/${GITSMART_RE_VERSPARTS}/\1 \2 \4 \5 \6/"))

  echo "${partsarr[@]}"
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

resolve_version_next () {
  local curr_version="$1"
  local part_or_version="$2"
  local version_tag

  if echo "${part_or_version}" | grep -E "${GITSMART_RE_VERSPARTS}" > /dev/null; then
    # A version. Compare against latest.
    insist_next_version_gt_curr_version "${part_or_version}" "${curr_version}"
    version_tag="${part_or_version}"
  else
    version_tag="$(resolve_version_bump "${curr_version}" "${part_or_version}")"
    [ $? -ne 0 ] && exit 1
  fi

  echo "${version_tag}"
}

# ***

resolve_version_bump () {
  local curr_version="$1"
  local part_or_version="$2"
  local partsarr

  partsarr="$(latest_version_parts "${curr_version}")"

  local major minor patch seppa alpha

  IFS=' ' read major minor patch seppa alpha <<< "${partsarr[@]}"

  case "${part_or_version}" in
    M | -M | ma | major)
      let 'major += 1'; minor=0; patch=0; seppa=; alpha=;
      ;;
    m | -m | mi | minor)
      let 'minor += 1'; patch=0; seppa=; alpha=;
      ;;
    p | -p | pa | patch)
      let 'patch += 1'; seppa=; alpha=;
      ;;
    a | -a | al | alpha)
      # The alpha part is the only part not guaranteed to be a number.
      # Note that if no current alpha, must inc. patch to be < current vers.
      [ -z "${alpha}" ] && let 'patch += 1'
      let 'alpha += 1' || (>&2 echo "ERROR: Cannot bump non-number alpha part" && exit 1)
      ;;
    s | -s | same)
      ;;
    d | -d | delete)
      # This function is called in a subshell, so we'll scan again later to set
      #  ACTION_DELETE=true.
      ;;
    *)
      >&2 echo "ERROR: Unknown bump part specifier: ‚Äú${part_or_version}‚Äù"
      exit 1
      ;;
  esac

  version_tag="${major:-0}.${minor:-0}"

  [ -n "${patch}" ] && version_tag="${version_tag}.${patch}"

  version_tag="${major:-0}.${minor:-0}.${patch:-0}"

  [ "${version_tag}" = "0.0.0" ] && version_tag="0.0.1"

  [ -n "${alpha}" ] && version_tag="${version_tag}${seppa:-a}${alpha}"

  echo "${version_tag}"
}

# ***

insist_next_version_gt_curr_version () {
  local next_version="$1"
  local curr_version="$2"

  pep440cmp "${next_version}" gt "${curr_version}" > /dev/null && return

  >&2 echo "ERROR: Desired version not greater than current version!"
  >&2 echo "  ‚Äú${next_version}‚Äù !> ‚Äú${curr_version}‚Äù"

  exit 1
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

parse_args_for_delete () {
  ACTION_DELETE=false

  local part_or_version="$1"

  if ! ( echo "${part_or_version}" | grep -E "${GITSMART_RE_VERSPARTS}" > /dev/null ); then
    case "${part_or_version}" in
      d | -d | delete)
        ACTION_DELETE=true
        ;;
      *)
        ;;
    esac
  fi
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

git_tvp_confirm_next () {
  local version_tag="$1"
  local curr_version="$2"

  local do_what_now="start versioning at"
  if [ -n "${curr_version}" ]; then
    do_what_now="bump ‚Äú${curr_version}‚Äù ‚Üí"
  fi

  local msg="Okay to ${do_what_now} ‚Äú${version_tag}‚Äù"
  local the_choice

  the_choice=$(SKIP_PROMPT_NL=true ask_yesnoskip "${msg}" "Y")

  [ $? -ne 0 ] && exit 1

  [ "${the_choice}" != "y" ] && return 1 || return 0
}

git_tvp_confirm_delete () {
  local version_tag="$1"
  local msg="Okay to delete ‚Äú${version_tag}‚Äù"
  local the_choice

  the_choice=$(SKIP_PROMPT_NL=true ask_yesnoskip "${msg}" "Y")

  [ $? -ne 0 ] && exit 1

  [ "${the_choice}" != "y" ] && return 1 || return 0
}

git_tvp_confirm_push () {
  local version_tag="$1"
  # ${DRY_RUN} && return
  local msg="Okay to push ‚Äú${version_tag}‚Äù"
  local the_choice

  the_choice=$(SKIP_PROMPT_NL=true ask_yesnoskip "${msg}" "Y")

  [ $? -ne 0 ] && exit 1

  [ "${the_choice}" != "y" ] && return 1 || return 0
}

echo_or_eval () {
  ${DRY_RUN} && echo "DRY_RUN: $@" || eval "$@"
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

git_tag_local_add () {
  local version_tag="$1"
  local curr_version="$2"

  ${ACTION_DELETE} && return

  [ "${version_tag}" = "${curr_version}" ] && return

  git_tvp_confirm_next "${version_tag}" "${curr_version}" || return

  # Note that this command tags HEAD, as opposed to a specific branch.
  # E.g., we could tag, say, the release branch:
  #   git tag -a ${version_tag} -m "Version: ${version_tag}" "release"
  # but that would probably be confusing to the user. So stick to HEAD.
  echo_or_eval git tag -a "${version_tag}" -m "'Version: ${version_tag}'"
}

git_tag_local_delete () {
  local version_tag="$1"

  ${ACTION_DELETE} || return

  git_tvp_confirm_delete "${version_tag}" || return

  echo_or_eval git tag -d "${version_tag}"
}

git_tag_remote_delete () {
  local version_tag="$1"
  local remote_name="$2"

  must_remote_exists "${remote_name}"

  # (lb): I considerd making the ls-remote call (which, e.g., pings GitHub)
  # to be optional. But it's just as easy to Ctrl-C when the script gets here.

  # Network call!
  R2G2P_REMOTE="${remote_name}" \
  RELEASE_VERSION="${version_tag}" \
  R2G2P_COMMIT="$(git rev-parse HEAD)" \
  R2G2P_GHUB_CLOBBER_CERTIFIED=${ACTION_DELETE} \
  github_purge_release_and_tags_of_same_name
  #
  ${R2G2P_DO_PUSH_TAG:-false} || return

  # Note that if the tag existing, it may have been removed in call to
  # github_purge_release_and_tags_of_same_name, so can return now on
  # delete command.
  ${ACTION_DELETE} && return

  git_tvp_confirm_push "${version_tag}" || return

  # NOTE: This'll push both commit and tag, as necessary.
  #       - And GitHub will make a release object, too.
  local branch="$(git_branch_name)"

  echo_or_eval git push "${remote_name}" "${branch}" "refs/tags/${version_tag}"
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

git_wip_commit_if_untidy () {
  local wipped=false

  # If nothing is staged, git-commit fails, but we'll check git-status anyway.
  test -n "$(git status --porcelain=v1)" \
    && git add -A \
    && git commit -q --no-verify -m 'PRIVATE: WIP [git-bump-version-tag]' > /dev/null \
    && wipped=true

  printf "%s" "${wipped}"
}

git_pop_wip_commit_maybe () {
  local wipped="$1"

  ${wipped} && git reset -q --mixed @~1
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

git_tvp_tag_vers_push () {
  local part_or_version="${1:-patch}"
  local remote_name="${2}"

  # Remind user if they're dry-running.
  ${DRY_RUN} && echo "# TEST AHOY! (DRY_RUN=true)"

  # ***

  # Default to the remote tracking branch remote, or fallback to "origin".
  [ -z "${remote_name}" ] && remote="$(git_upstream_parse_remote_name)"
  [ -z "${remote_name}" ] && remote="origin"

  # Insist run from within a Git project.
  git_insist_git_repo || exit 1

  # Create temporary WIP commit if untidy.
  _WIPPED="$(git_wip_commit_if_untidy)"

  # ***

  local headvers="$(git_branch_head_version)"

  # We don't need the remote to exist; we can still tag the local branch.
  # SKIP:
  #   must_remote_exists "${remote_name}"
  warn_remote_absent "${remote_name}"

  local curr_version="$(git_latest_version_tag)"

  local version_tag
  version_tag="$(resolve_version_next "${curr_version}" "${part_or_version}")"
  [ $? -ne 0 ] && exit 1

  parse_args_for_delete "${part_or_version}"

  # Insist HEAD unversioned or matches desired.
  must_head_unversioned_or_matching "${headvers}" "${curr_version}" "${remote_name}"

  git_tag_local_add "${version_tag}" "${curr_version}"
  git_tag_local_delete "${version_tag}"

  git_tag_remote_delete "${version_tag}" "${remote_name}"
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

_WIPPED=false

function exit_cleanup () {
  git_pop_wip_commit_maybe "${_WIPPED}"
}
trap exit_cleanup EXIT

# ***

main () {
  source_deps "${BASH_SOURCE[0]}" || exit 1

  git_tvp_tag_vers_push "$@"
}

if [ "$0" = "${BASH_SOURCE[0]}" ]; then
  main "${@}"
fi

# Unhook exit_cleanup.
trap - EXIT

