#!/usr/bin/env bash
# vim:tw=0:ts=2:sw=2:et:norl:ft=bash
# Author: Landon Bouma (landonb &#x40; retrosoft &#x2E; com)
# Project: https://github.com/landonb/git-bump-version-tag#üê´
# Copyright ¬© 2020 Landon Bouma. All rights reserved.
# License: MIT. Please find more in the LICENSE file.

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

# YOU: Uncomment (or set from environment) for a dry run:
#  DRY_RUN=true
DRY_RUN=${DRY_RUN:-false}

BUMP_PRERELEASE_BASE="${BUMP_PRERELEASE_BASE:--alpha.}"

BUMP_REMOTE_BRANCH_NAME="${BUMP_REMOTE_BRANCH_NAME:-release}"

BUMP_VERBATIM="${BUMP_VERBATIM:-false}"

BUMP_SKIP_REMOTE="-"

# USYNC: Same environ name as what git-put-wise uses.
# CXREF: https://github.com/DepoXy/git-put-wise#ü•®
#   ~/.kit/git/git-put-wise/lib/common_put_wise.sh
#
#  SCOPING_PREFIX="${SCOPING_PREFIX:-PROTECTED: }"
#  PRIVATE_PREFIX="${PRIVATE_PREFIX:-PRIVATE: }"

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

USAGE="\
USAGE: $(basename "$0") [OPTIONS...] [<VERSIONTAG>] [--] [<REMOTE>] [<COMMIT>]

OPTIONS: One or more of:

  [s|-s|same
  |d|-d|delete
  |P|-P|push
  |M|-M|major
  |m|-m|minor
  |p|-p|patch
  |a|-a|alpha
  |v|-v|v-pre
  |V|-V|v-del]

- s, -s, same    Use current version (don't bump)
                 - Useful if you only tagged locally,
                   and would like to push that tag now

- d, -d, delete  Delete latest version tag (local and remote)
                 - Useful if you messed up ‚Äî but it's on you to ensure it's
                   not too late to delete a tag you previously published!

- P, -P, push    Push tag (default action when not 'delete')

- M, -M, major   Bump major version by one

- m, -m, minor   Bump minor version by one

- p, -p, patch   Bump patch version by one

- a, -a, alpha   Bump pre-release version by one
                 - This only works if the pre-release part ends in a number
                 - Use BUMP_PRERELEASE_BASE to set the default prerelease
                   value (defaults: ‚Äú${BUMP_PRERELEASE_BASE}‚Äù)
                   - E.g., given current version 1.2.3, then
                       $ git bump major alpha
                     will create version 2.0.0${BUMP_PRERELEASE_BASE}1
                   - BUMP_PRERELEASE_BASE is ignored if the previous tag
                     is already prerelease, and its value is used instead

- v, -v, v-pre   Use \"v\" tag prefix
                 - Adds v-prefix if previous tag was not v-prefixed

- V, -V, v-del   Remove \"v\" tag prefix
                 - Removes v-prefix if previous tag was v-prefixed

The \"patch\" option will be assumed if no option is specified

Options can be specified individually or as a classic clump
- E.g., \`git bump minor alpha\` is the same as \`git bump ma\`
- Though beware if a clump option matches a known remote name,
  then it's assumed to be the <REMOTE> argument instead
  (in which case you cannot use the clump format)

ARGUMENTS:

- <VERSIONTAG>
            Use this to specify the next version tag explicitly
            - Useful when versioning for the first time (though
              bump specifiers will bump from 0, so they work, too)
            - Useful for specifying a uniquely-named prerelease version

- <REMOTE>  Specify which remote to use
            - If not specified, will default to the remote specified
              by the local upstream branch
            - If local branch does not have an upstream (you can set
              one via \`git branch -u <remote/branch>\`), uses 'origin'
            - Specify \"-\" to skip remote tag push altogether.
            - ALERT: You must use \`--\` before remote name if it
              could be interpreted as an OPTIONS sequence, or if the
              remote name is also a valid version

- <COMMIT>  Specify commit to tag, either SHA-1 hash, or \"HEAD\"
            - If not specified, defaults to remote branch HEAD commit
            - If \"HEAD\" is specified and git-put-wise is installed,
              this will tag only the most recent \"non-scoped\" local
              commit
              - A non-scoped commit is indicated by a commit message
                with a specific prefix, either PRIVATE_PREFIX (set to
                \"${PRIVATE_PREFIX:-PRIVATE: }\") or SCOPING_PREFIX
                (set to \"${SCOPING_PREFIX:-PROTECTED: }\")
            - If \"HEAD\", will also push latest commits to remote
              before tagging.

OVERRIDES: Set these environment variables for alternative behavior:

- BUMP_PRERELEASE_BASE=\"${BUMP_PRERELEASE_BASE}\"
            Prerelease part prefix, used by a|alpha

- BUMP_REMOTE_BRANCH_NAME=\"${BUMP_REMOTE_BRANCH_NAME}\"
            Name of remote branch whose HEAD commit will be tagged,
            if unable to determine the remote branch automatically
            - By default uses the default branch for the remote for
              the local upstream branch (i.e., looks for 'HEAD branch'
              from \`git remote show <remote>\`), and this environ is
              only used if the default branch is indeterminable

- BUMP_VERBATIM=${BUMP_VERBATIM}
            If true, applies all patch options in the order encountered
            - E.g., if not verbatim, then
                $ git bump Mmp
              will only bump the largest part (major)
              - So version 1.2.3 ‚Üí 2.0.0
              - But if BUMP_VERBATIM=true, then the version
                increments 1.2.3 ‚Üí 2.0.0 ‚Üí 2.1.0 ‚Üí 2.1.1
              - As stated, the options are applied in order, so
                reversing 'Mmp' to 'pmM' would result in 2.0.0:
                  $ git bump pmM
                would bump 1.2.3 ‚Üí 1.2.4 ‚Üí 1.3.0 ‚Üí 2.0.0
            - Regardless of BUMP_VERBATIM, you are always allowed to mix
              an alpha bump with any of the other parts (major|minor|patch)
              - E.g., if at version 1.2.3, you can easily start a new alpha
                version at 1.2.4-alpha.1, 1.3.0-alpha.1, or 2.0.0-alpha.1
            - (As an aside, we're unclear BUMP_VERBATIM is very useful)

SCOPING_PREFIX=\"${SCOPING_PREFIX:-PROTECTED: }\"
PRIVATE_PREFIX=\"${PRIVATE_PREFIX:-PRIVATE: }\"
            Specifies the commit message prefixes that designate which
            commits should not be published
            - Used when <COMMIT> is specified as \"HEAD\"
            - Only works if git-put-wise is installed
              (see note under <COMMIT>, above)
              - You can find git-put-wise at
                https://github.com/DepoXy/git-put-wise#ü•®
"

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

source_deps () {
  # Optional: 'pep440cmp'.
  # https://github.com/hotoffthehamster/pep440-version-compare-cli

  # Need Dunamai to normalize for SemVer or PEP 440.
  # CXREF: https://github.com/mtkennerly/dunamai
  insist_cmd 'dunamai'

  # Need Perl for fancy SemVer regex.
  insist_cmd 'perl'

  # Ensure coreutils installed (from Linux pkg. mgr., or from macOS Homebrew).
  insist_cmd 'realpath'

  # Load ask_yesnoskip.
  # https://github.com/landonb/sh-ask-yesnoskip
  . "$(dirname "$(realpath "$0")")/../deps/sh-ask-yesnoskip/bin/ask-yesnoskip.sh"

  # Load git_* functions, including
  #   git_branch_name
  #   git_insist_git_repo
  #   git_largest_version_tag
  #   git_remote_exists
  #   git_versions_tagged_for_commit_object
  #   git_tag_remote_verify_commit;
  # and load environs, incl. GITSMART_RE_VERSPARTS, GITSMART_RE_SEMVERSPARTS.
  # CXREF: https://github.com/landonb/sh-git-nubs
  #   ~/.kit/sh/sh-git-nubs/bin/git-nubs.sh
  . "$(dirname "$(realpath "$0")")/../deps/sh-git-nubs/bin/git-nubs.sh"

  # Optional: git-put-wise, for 'identify_scope_ends_at'.
  # https://github.com/DepoXy/git-put-wise#ü•®
  if command -v git-put-wise > /dev/null; then
    local put_wise_bin="$(dirname "$(realpath "$(command -v git-put-wise)")")"
    . "${put_wise_bin}/../lib/common_put_wise.sh"
    . "${put_wise_bin}/../lib/dep_apply_confirm_patch_base.sh"
  fi
}

insist_cmd () {
  local cmdname="$1"

  command -v "${cmdname}" > /dev/null && return

  >&2 echo "ERROR: Missing system command ‚Äò${cmdname}‚Äô."

  exit 1
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

insist_tag_commit_unversioned_or_same_version () {
  local version_tag="$1"
  local tag_commit="$2"

  local existing_tags
  existing_tags="$(git_versions_tagged_for_commit_object "${tag_commit}")"

  if [ -n "${existing_tags}" ]; then
    local num_versions="$(echo "${existing_tags}" | wc -l)"

    if [ ${num_versions} -gt 1 ]; then
      >&2 echo "ERROR: The target commit has more than one version tag:"
      >&2 echo "${existing_tags}"

      exit 1
    fi

    local current_version="${existing_tags}"

    if [ "${current_version}" != "${version_tag}" ]; then
      # We could allow this, but seems like an unlikely use case,
      # or rather, I can't think of a valid end user use case for
      # tagging the same commit with more than one version, so
      # block it.
      >&2 echo "ERROR: The target commit is already version-tagged: ${current_version}"

      exit 1
    fi
  fi
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

print_git_remote_default_branch_name () {
  local remote_name="$1"

  local branch_names num_branches remote_branch

  # If remote only has one branch, use it.
  branch_names="$(git branch -a --list "${remote_name}/*")"
  num_branches="$(echo "${branch_names}" | wc -l)"

  if [ ${num_branches} -eq 0 ]; then
    >&2 echo "ERROR: No local branches found for remote '${remote_name}'." \
      "Perhaps you need to fetch?"

    exit 1
  fi

  if [ ${num_branches} -eq 1 ]; then
    remote_branch="$(echo "${branch_names}" | sed 's#^.*/##')"
  else
    # Note that git_remote_default_branch is a network call (git remote show),
    # so we try to avoid it. Above, we checked if remote only has one branch.
    # Here we know there are multiple branches.
    # - One last resort to avoid network call: Check environ "config" value.
    branch_names="$(git branch -a --list "${remote_name}/${BUMP_REMOTE_BRANCH_NAME}")"
    if [ -n "${branch_names}" ]; then
      remote_branch="$(echo "${branch_names}" | sed 's#^.*/##')"
    else
      # ALERT: Network call.
      remote_branch="$(git_remote_default_branch "${remote_name}")"
    fi
  fi

  # Shouldn't happen, we assume.
  [ -z "${remote_branch}" ] \
    && >&2 echo "FATAL: Where's remote branch?" \
    && exit 1

  printf "%s" "${remote_branch}"
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

must_remote_exists () {
  local remote_name="$1"

  git_remote_exists "${remote_name}" && return

  >&2 echo "ERROR: No remote named ‚Äú${remote_name}‚Äù"

  exit 1
}

# Some CI workflows might version tag automatically,
# so periodically fetch to try to ensure up to date.
# - We could fetch every time, but this is a network
#   operation, and sometimes you're too in the zone
#   to be bothered.
# - MAYBE: Is there a better approach to gating `fetch`?
periodically_fetch () {
  local remote_name="$1"

  BUMP_CONFIG_SECTION="tools.git-bump-version-tag"
  BUMP_CONFIG_LAST_FETCH="lastfetch"

  local last_update="$(git config ${BUMP_CONFIG_SECTION}.${BUMP_CONFIG_LAST_FETCH})"

  local do_fetch=true
  if [ -n "${last_update}" ]; then
    if [ ${last_update} -gt $(date -d '-1 hour' +'%s') ]; then
      do_fetch=false
    fi
  fi
  
  if ${do_fetch}; then
    # We could `git fetch "${remote_name}" --tags` get tags only,
    # but should update default branch, too.
    git fetch "${remote_name}"

    git config ${BUMP_CONFIG_SECTION}.${BUMP_CONFIG_LAST_FETCH} "$(date +%s)"
  fi
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

latest_version_parts () {
  local curr_version="$1"

  # See also: GITSMART_RE_SEMVERSPARTS. Here we use looser regex so we
  # can read any style version and increment any part of it. Then later
  # we'll use the dunamai library to normalize the version according to
  # style.

  # Note the '!' in '\1!', so that `read` parses the string correctly when
  # there is no v-prefix (i.e., ensure there's a word there for `read`).
  # - Use perl, not sed, because there's a Perl-only .*? non-greedy in the regex.
  partsstr="$(
    command perl -pe "s/${GITSMART_RE_VERSPARTS}/\1! \2 \3 \5 \6 \7/" <<<"${curr_version}"
  )"

  echo "${partsstr}"
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

must_resolve_new_version_tag () {
  local curr_version="$1"
  shift

  # Sets VERSION_TAG and ACTION_DELETE,
  # and maybe REMOTE_NAME, and/or TAG_COMMIT.
  resolve_version_bump "${curr_version}" "$@"
}

# ***

resolve_version_bump () {
  local curr_version="$1"
  shift

  local partsstr
  partsstr="$(latest_version_parts "${curr_version}")"

  local vprefix major minor patch prerelease finalnum

  IFS=' ' read vprefix major minor patch prerelease finalnum <<< "${partsstr}"

  # ${DRY_RUN} && echo "read: v:${vprefix} M:${major} m:${minor}" \
  #   "p:${patch} a:${prerelease} n:${finalnum} (${partsstr})"

  # Strip the '!' from the v-prefix (which was used to support `read`).
  vprefix="${vprefix%!}"

  local bumped_patch_or_better=false
  local bmajor=false bminor=false bpatch=false balpha=false
  local bump_verbatim="${BUMP_VERBATIM:-false}"
  local bumps_count=0

  add_prefix () {
    vprefix="v"
  }

  del_prefix () {
    vprefix=""
  }

  bump_bumps_count () {
    let 'bumps_count += 1'
  }

  bump_major () {
    bump_bumps_count
    ! ${bump_verbatim} && bmajor=true && return

    # Note that if var. unset, the let += 1 sets it to 1.
    let 'major += 1'; minor=0; patch=0; prerelease=; finalnum=;
    bumped_patch_or_better=true
  }

  bump_minor () {
    bump_bumps_count
    ! ${bump_verbatim} && bminor=true && return

    let 'minor += 1'; patch=0; prerelease=; finalnum=;
    bumped_patch_or_better=true
  }

  bump_patch () {
    bump_bumps_count
    ! ${bump_verbatim} && bpatch=true && return

    let 'patch += 1'; prerelease=; finalnum=;
    bumped_patch_or_better=true
  }

  # What SemVer calls "pre-release".
  bump_alpha () {
    bump_bumps_count
    ! ${bump_verbatim} && balpha=true && return

    if [ -z "${prerelease}" ]; then
      # If no current alpha, must bump patch so new version is < current vers.
      ! ${bumped_patch_or_better} && let 'patch += 1'
      prerelease="${BUMP_PRERELEASE_BASE:--alpha.}"
      finalnum="1"
    else
      let 'finalnum += 1'
    fi
  }

  local skip_opts=0
  local n_extra_args=0

  VERSION_TAG=""
  ACTION_DELETE=false
  ACTION_PUSH=false
  REMOTE_NAME=""
  TAG_COMMIT=""

  local ACTION_SAME=false
  local VERSION_ARG=""

  while [ -n "$1" ]; do
    local cur_arg="$1"
    shift

    if [ ${skip_opts} -gt 0 ]; then
      if [ ${skip_opts} -eq 1 ]; then
        if is_known_remote "${cur_arg}"; then
          skip_opts=2

          REMOTE_NAME="${cur_arg}"
        elif is_known_commit_sha "${cur_arg}"; then
          skip_opts=3

          TAG_COMMIT="${cur_arg}"
        else
          >&2 echo "ERROR: Expected <REMOTE> or <COMMIT>, not: ‚Äú${cur_arg}‚Äù"

          exit 1
        fi
      elif [ ${skip_opts} -eq 2 ]; then
        skip_opts=3

        if is_known_commit_sha "${cur_arg}"; then
          TAG_COMMIT="${cur_arg}"
        else
          >&2 echo "ERROR: Expected <COMMIT>, not: ‚Äú${cur_arg}‚Äù"

          exit 1
        fi
      else
        # Case: [ ${skip_opts} -ge 3 ]
        >&2 echo "ERROR: Unrecognized argument: ‚Äú${cur_arg}‚Äù"
        >&2 echo "- Or maybe you specified more than one"
        >&2 echo "   <VERSIONTAG>, <REMOTE>, or <COMMIT>"

        exit 1
      fi
    elif [ "${cur_arg}" = '--' ]; then
      skip_opts=1
    elif like_a_version "${cur_arg}"; then
      skip_opts=1

      VERSION_ARG="${cur_arg}"
    elif is_known_remote "${cur_arg}"; then
      skip_opts=2

      REMOTE_NAME="${cur_arg}"
    elif is_known_commit_sha "${cur_arg}"; then
      skip_opts=3

      TAG_COMMIT="${cur_arg}"
    else
      case "${cur_arg}" in
        s | -s | same)
          ACTION_SAME=true
          VERSION_TAG="${curr_version}"
          ;;
        d | -d | delete)
          ACTION_DELETE=true
          VERSION_TAG="${curr_version}"
          ;;
        P | -P | push)
          ACTION_PUSH=true
          ;;
        h | -h | help | --help)
          >&2 echo "${USAGE}"

          exit 1
          ;;
        M | -M | major) bump_major ;;
        m | -m | minor) bump_minor ;;
        p | -p | patch) bump_patch ;;
        a | -a | alpha) bump_alpha ;;
        v | -v | v-pre) add_prefix ;;
        V | -V | v-del) del_prefix ;;
        *)
          for char in $(echo "${cur_arg#-}" | sed -E -e 's/(.)/\1\n/g'); do
            case ${char} in
              s) ACTION_SAME=true;
                 VERSION_TAG="${curr_version}" ;;
              d) ACTION_DELETE=true;
                 VERSION_TAG="${curr_version}" ;;
              P) ACTION_PUSH=true ;;
              M) bump_major ;;
              m) bump_minor ;;
              p) bump_patch ;;
              a) bump_alpha ;;
              v) add_prefix ;;
              V) del_prefix ;;
              *)
                >&2 echo "ERROR: Unrecognized argument: ‚Äú${cur_arg}‚Äù"

                exit 1
                ;;
            esac
          done
      esac
    fi
  done

  if [ -n "${VERSION_TAG}" ]; then
    # Means 'same' and/or 'delete' specified.
    if [ ${bumps_count} -gt 0 ]; then
      >&2 echo "ERROR: Cannot indicate bump (M|m|p|a), and pick 'same' (s) or delete (d)."

      exit 1
    elif ${ACTION_SAME} && [ -n "${VERSION_ARG}" ]; then
      >&2 echo "ERROR: Cannot indicate 'same' (s), and specify <VERSIONTAG>."

      exit 1
    fi
  fi

  if [ -n "${VERSION_ARG}" ]; then
    # Means <VERSIONTAG> specified.
    if [ ${bumps_count} -gt 0 ]; then
      >&2 echo "ERROR: Cannot indicate bump (M|m|p|a), and specify <VERSIONTAG>."

      exit 1
    fi
    # else, we already checked not 'same' and <VERSIONTAG> specified.
    # - But if 'delete' specified, be sure to delete <VERSIONTAG>.

    VERSION_TAG="${VERSION_ARG}"
  fi

  if [ -z "${VERSION_TAG}" ]; then
    # Ugh, apologies for such a long if, and long function...
    if ! ${bump_verbatim}; then
      bump_verbatim=true

      # We could let user bump more than one part, e.g.,
      #
      #   ${bmajor} && bump_major
      #   ${bminor} && bump_minor
      #   ${bpatch} && bump_patch
      #   ${balpha} && bump_alpha
      #
      # but that's what VERBATIM_BUMP=true is for: to let
      # user specify their own bump recipe, and we play
      # along.
      #
      # But for most users, we'll be strict and assume
      # they only want to bump on component (like, why
      # do you want to skip versions? If if that's what
      # you really want, use VERBATIM_BUMP).

      local warn_too_many=false
      ${balpha} && let 'bumps_count -= 1'
      [ ${bumps_count} -gt 1 ] && warn_too_many=true

      bumps_count=0

      local biggest=""

      # Idea here is we only honor bumping single component.
      if ${bmajor}; then
        bump_major
        biggest="major"
      elif ${bminor}; then
        bump_minor
        biggest="minor"
      elif ${bpatch}; then
        bump_patch
        biggest="patch"
      fi

      # User can always mix alpha bump with any previous bump,
      # so they can easily create next version alpha release.
      if ${balpha}; then
        bump_alpha
        # We'd never use this `biggest`.
        #  biggest="prerelease"
      fi

      if [ ${bumps_count} -eq 0 ]; then
        # Should be impossible path, because ${part_or_version} defaults 'patch'.
        >&2 echo "ERROR: Please specify a bump part (M|m|p|a) or choose same (s)."

        exit 1
      elif ${warn_too_many}; then
        >&2 echo "WARNING: Only the biggest non-alpha bump option will be used (${biggest})."
        >&2 echo "- If you want to bump more than one part, toggle \`BUMP_VERBATIM=true\`"
        # Otherwise don't specify more than one part (and no need to make this
        # warning message optional).
      fi
    fi

    pdot=""
    [ -z "${patch}" ] || pdot="."

    # ${DRY_RUN} && echo "version_tag: v:${vprefix} M:${major:-0} m:${minor:-0}" \
    #   "?:${pdot} p:${patch} a:${prerelease} n:${finalnum}"
    version_tag="${vprefix}${major:-0}.${minor:-0}${pdot}${patch}${prerelease}${finalnum}"

    VERSION_TAG="${version_tag}"
  fi

  ${DRY_RUN} && echo "VERSION_TAG=${VERSION_TAG}"
}

like_a_version () {
  local word="$1"

  echo "${word}" | command grep -q -E "${GITSMART_RE_VERSPARTS}"
}

is_known_remote () {
  local word="$1"

  # "-" means skip remote tag push.
  [ "${word}" = "${BUMP_SKIP_REMOTE}" ] && return 0

  starts_with_alphanum "${word}" || return 1

  git remote get-url "${word}" > /dev/null 2>&1
}

is_known_commit_sha () {
  local word="$1"

  starts_with_alphanum "${word}" || return 1

  [ "${word}" = "HEAD" ] && return 0

  git rev-parse "${word}" > /dev/null 2>&1 || return 1

  [[ "$(git rev-parse "${word}")" = "${word}"* ]]
}

# - A hostname may not start with a hyphen:
#     <name>  ::= <let>[*[<let-or-digit-or-hyphen>]<let-or-digit>]
#   https://www.rfc-editor.org/rfc/rfc952
#   - A hostname may start with an alpha or a digit:
#     https://www.rfc-editor.org/rfc/rfc1123#section-2
# - Same with SHA, starts with alphanum. No biblio needed.
starts_with_alphanum () {
  local word="$1"

  echo "${word}" | command grep -q -E -e "^[a-zA-Z0-9]+$"
}

# ***

insist_next_version_gt_curr_version () {
  local next_version="$1"
  local curr_version="$2"
  local tag_commit="$3"

  local is_newer_version=true

  insist_prev_version_gt_earlier_version \
    "${next_version}" "${curr_version}" "${tag_commit}" \
    > /dev/null 2>&1 \
      || is_newer_version=false

  # Optional: 'pep440cmp'
  if ! command -v pep440cmp > /dev/null; then
    if ${GIT_BUMP_VERSION_TAG_PEP400CMP_ENABLE:-false}; then
      >&2 echo "ALERT: Cannot verify next version greater than current version."
      >&2 echo "- Please install pep440cmp, e.g.,"
      >&2 echo "    pipx install pep440-version-compare-cli"
      >&2 echo "- CXREF:"
      >&2 echo "    https://github.com/hotoffthehamster/pep440-version-compare-cli"
    fi
  else
    pep440cmp "${next_version}" gt "${curr_version}" > /dev/null \
      || is_newer_version=false
  fi

  if ! ${is_newer_version}; then
    if ! ${ACTION_DELETE}; then
      >&2 echo "ERROR: Desired version not greater than current version!"
      >&2 echo "  ‚Äú${next_version}‚Äù !> ‚Äú${curr_version}‚Äù"

      exit 1
    fi

    >&2 echo
    >&2 echo "ALERT: You are deleting a version older than the current version!"
    >&2 echo
  fi
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

# CXREF: SemVer Perl regex, from the source, unaltered.
#   https://semver.org/
#   https://regex101.com/r/Ly7O1x/3/
insist_new_version_semver_compliant () {
  local version_tag="$1"

  local vless_version="$(echo "${version_tag}" | sed 's/^v//')"

  local semver
  semver="$(
    perl -ne "print if /${GITSMART_RE_SEMVERSPARTS}/" <<<"${vless_version}"
  )"

  if [ -z "${semver}" ]; then
    >&2 echo "ERROR: The new version is not SemVer compliant: ${vless_version}"
    # dunamai normalized the version value, and dunamai is never wrong
    # (so if you see this message, it's prob in GITSMART_RE_SEMVERSPARTS).
    >&2 echo "- Unexpected: You should never see this message!"

    exit 1
  fi
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

git_bump_confirm_next () {
  local version_tag="$1"
  local curr_version="$2"

  local do_what_now="start versioning at"
  if [ -n "${curr_version}" ]; then
    if [ -n "${TAG_COMMIT}" ]; then
      do_what_now="backfill tag"
    else
      do_what_now="bump ‚Äú${curr_version}‚Äù ‚Üí"
    fi
  fi

  local msg="Okay to ${do_what_now} ‚Äú${version_tag}‚Äù"
  local the_choice

  the_choice=$(SKIP_PROMPT_NL=true ask_yesnoskip "${msg}" "Y")

  [ $? -ne 0 ] && exit 1

  [ "${the_choice}" != "y" ] && return 1 || return 0
}

git_bump_confirm_normalize () {
  local version_tag="$1"
  local normal_vers="$2"

  local msg="Okay to normalize ‚Äú${version_tag}‚Äù ‚Üí ‚Äú${normal_vers}‚Äù"

  local the_choice
  the_choice=$(SKIP_PROMPT_NL=true ask_yesnoskip "${msg}" "Y")

  [ $? -ne 0 ] && exit 1

  [ "${the_choice}" != "y" ] && return 1 || return 0
}

git_bump_confirm_delete () {
  local version_tag="$1"
  # local remote_name="$2"
  local remote_name="${2:-localhost}"

  local msg="Okay to delete ‚Äú${version_tag}‚Äù"

  if [ -n "${remote_name}" ]; then
    msg="${msg} from ‚Äú${remote_name}‚Äù"
  fi

  local the_choice
  the_choice=$(SKIP_PROMPT_NL=true ask_yesnoskip "${msg}" "Y")

  [ $? -ne 0 ] && exit 1

  [ "${the_choice}" != "y" ] && return 1 || return 0
}

git_bump_confirm_push () {
  local version_tag="$1"
  local remote_name="$2"

  local msg="Okay to push ‚Äú${version_tag}‚Äù to ‚Äú${remote_name}‚Äù"

  local the_choice
  the_choice=$(SKIP_PROMPT_NL=true ask_yesnoskip "${msg}" "Y")

  [ $? -ne 0 ] && exit 1

  [ "${the_choice}" != "y" ] && return 1 || return 0
}

# ***

git_bump_print_conflict_alert () {
  local version_tag="$1"
  local remote_name="$2"
  local tag_commit="$3"

  echo
  echo "üö® ATTENTION üö®: The tag ‚Äò${version_tag}‚Äô on remote ‚Äò${remote_name}‚Äô"
  echo "                 refers to a different commit than the local target:"
  echo
  echo "    target tag ref  ${tag_commit}"
  echo "    remote tag ref  ${GNUBS_TAG_COMMIT_OBJECT:-<missing-GNUBS_TAG_COMMIT_OBJECT>}"
  echo
  #
  # `git_tag_remote_verify_commit` sets a global to send back the tag commit ID.
  if [ -z "${GNUBS_TAG_COMMIT_OBJECT}" ]; then
    # Impossible path.
    >&2 echo "ERROR: Expected non-empty remote tag ref (GNUBS_TAG_COMMIT_OBJECT)"
  fi
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

echo_or_eval () {
  ${DRY_RUN} && echo "DRY_RUN: $@" || eval "$@"
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

git_tag_local_add () {
  local version_tag="$1"
  local tag_commit="$2"
  local curr_version="$3"

  if ! "${ACTION_PUSH}"; then
    if [ "${version_tag}" = "${curr_version}" ]; then
      echo "‚úì Local tag exists"

      return 0
    fi

    git_bump_confirm_next "${version_tag}" "${curr_version}" \
      || return 1
  fi

  # Note that this command tags HEAD, as opposed to a specific branch.
  # E.g., we could tag, say, the release branch:
  #   git tag -a ${version_tag} -m "Version: ${version_tag}" "release"
  # but that would probably be confusing to the user. So stick to HEAD.

  echo_or_eval git tag -a "${version_tag}" -m "'Version: ${version_tag#v}'" "${tag_commit}"

  echo "‚úì Created local tag"
}

git_tag_local_delete () {
  local version_tag="$1"

  if ! git_tag_exists "${version_tag}"; then
    echo "‚úì Missing local tag"

    return
  fi

  git_bump_confirm_delete "${version_tag}" "" \
    || return 1

  echo_or_eval git tag -d "${version_tag}"
}

github_release_delete () {
  local version_tag="$1"

  if ! gh release view "${version_tag}" > /dev/null 2>&1; then
    return
  fi

  # Don't need to prompt: `gh` has its own.
  #
  #  git_bump_confirm_delete "${version_tag}" "GitHub releases" \
  #    || return 1

  gh release delete "${version_tag}"
}

git_tag_remote_delete () {
  local version_tag="$1"
  local remote_name="$2"

  git_bump_confirm_delete "${version_tag}" "${remote_name}" \
    || return 1

  # (lb): I realize there's a less obtuse syntax to delete tags, e.g.,
  #           git push --delete ${remote_name} ${tag_name}
  #       But that syntax might also delete a branch of the same name.
  #       So be :obtuse, and be specific about what's being deleted.
  echo_or_eval git push "${remote_name}" ":refs/tags/${version_tag}"
}

git_tag_remote_push () {
  local version_tag="$1"
  local tag_commit="$2"
  local remote_name="$3"
  local remote_branch="$4"
  local skip_push_branch="$5"

  # We've already verified the remote name is defined locally:
  #
  #   must_remote_exists "${remote_name}"
  #
  # But we haven't attempted to contact the remote until now,
  # so we don't yet know that it's actually reachable/online.
  #
  # - The `git_tag_remote_verify_commit` function, below,
  #   calls git-ls-remote, which contacts the remote server.

  local verify_result

  # Prefix the git_tag_remote_verify_commit output to better
  # distinguish it from other messages.
  printf '%s' '- '

  # Delete remote version tag from target commit.
  # - This makes a network call (via git-ls-remote).
  # - This checks if the same version tag exists on the remote,
  #   and if it's applied to the same target commit or not.
  #   - If tag exists and applied to commit, returns GNUBS_TAG_PRESENT (0).
  #   - If tag exists but applied to a different commit,
  #     prompts user to delete that tag from the remote.
  #   - If tag doesn't exist, returns GNUBS_TAG_ABSENT (1).
  #   - On error, returns GNUBS_FAILED (-1).
  GNUBS_TAG_COMMIT_OBJECT=""
  git_tag_remote_verify_commit "${version_tag}" "${remote_name}" "${tag_commit}"
  verify_result=$?

  if [ ${verify_result} -eq ${GNUBS_FAILED} ]; then
    >&2 echo "ERROR: git_tag_remote_verify_commit failed"

    exit 1
  elif [ ${verify_result} -eq ${GNUBS_TAG_CONFLICT} ]; then
    git_bump_print_conflict_alert "${version_tag}" "${remote_name}" "${tag_commit}"

    # Return now if user declines delete, or if delete fails, so we don't
    # have to further process GNUBS_TAG_CONFLICT state.
    git_tag_remote_delete "${version_tag}" "${remote_name}" \
      || return 1

    verify_result=${GNUBS_TAG_ABSENT}
  fi

  # ***

  if ${ACTION_DELETE}; then
    if [ ${verify_result} -eq ${GNUBS_TAG_PRESENT} ]; then
      # Remove the tag. If the remote is on GitHub, this removes the lightweight
      # (non-annotated) release (e.g., from https://github.com/user/repo/releases)
      # that's automatically generated when the tag was initally applied.
      # - At least that's what I've observed: I'm not quite sure how it works,
      #   or where it's documented, just that deleting the tag clears the entry.
      github_release_delete "${version_tag}"
      git_tag_remote_delete "${version_tag}" "${remote_name}"
    fi

    return
  elif [ ${verify_result} -eq ${GNUBS_TAG_PRESENT} ]; then
    # The tag is already pushed.
    echo "‚úì Remote already up-to-date"

    return
  elif [ ${verify_result} -ne ${GNUBS_TAG_ABSENT} ]; then
    # Impossible path.
    >&2 echo "ERROR: Unexpected verify_result: ${verify_result} (expecting ${GNUBS_TAG_ABSENT})"

    return 1
  fi
  # else, [ ${verify_result} -eq ${GNUBS_TAG_ABSENT} ], so push it.

  # ***

  git_bump_confirm_push "${version_tag}" "${remote_name}" \
    || return 1

  # If user specified "HEAD" <COMMIT>, push that, too.
  # - Otherwise we're tagging the current remote branch HEAD,
  #   so this push would be meaningless (wasted network call).
  # - By pushing to ${remote_branch}, we ensure that user can
  #   work on that branch locally, tag it, and then push both
  #   the branch commit and the tag simultaneously (we don't
  #   require user to push branch themselves before bumping).
  #   - Note that we previously bailed if ${remote_branch} is
  #     not the same as the local branch.
  if ! "${skip_push_branch}"; then
    echo_or_eval git push "${remote_name}" "${tag_commit}:refs/heads/${remote_branch}"

    echo "‚úì Pushed remote branch"
  fi

  # Note that GitHub automatically creates a release for the tag,
  # but it'll be replaced after your CI runs and creates a proper
  # release (well, assuming you have a release workflow tied to a
  # version tag event).
  echo_or_eval git push "${remote_name}" "refs/tags/${version_tag}"

  echo "‚úì Pushed remote tag"
}

# ***

# DEBAR: We could also verify that the remote commit object
# doesn't have "hidden" tags, but it's an unlikely scenario,
# and git-ls-remote is costly (it's a slower network call).
#
# - How you could check: Call `git ls-remote --tag <remote>`,
#   parse results for ${tag_commit}, then examine tag names.
#
#   - Look for version tags, and complain (or fail) if there
#     are more than one version tags, or if the version tag
#     is different from ${version_tag}.
#
#   - We could do this from within the previous function,
#     git_tag_remote_push, e.g., after calling
#     git_tag_remote_verify_commit.
#
# - How you could create the situation: Create a tag, push it,
#   delete it (but not off the remote), create a new version tag
#   at the same commit, and push that tag.
#
#   - Now the remote has two version tags on the same commit.
#
# - This app already prevents double-versioning locally. It'll
#   refuse to run if ${tag_commit} already has a version different
#   than ${version_tag}. See:
#
#     insist_tag_commit_unversioned_or_same_version
#
#   - So the scenario described only happens if the user
#     fails to delete remote tags after deleting locally.
#
# - But it's really not a big deal if there are multiple versions
#   on the same commit. It mostly just looks funny (sloppy).
#
# - Considering all that, and that git-ls-remote is a slower
#   network call, we won't check integrity of tags applied to
#   ${tag_commit} on the remote.
#
#   - But in the call to `git_tag_remote_verify_commit`, we do
#     check the integrity of at least the version tag applied on
#     the remote -- the function fails if the version tag is
#     already applied on the remote, but to a different commit.
#
#     - This is your classic `git push --force` situation,
#       except we don't know which tag is the "correct" tag,
#       be it the local tag, or the remote tag.
#
#     - So we need the user to decide which tag to keep,
#       and which tag to clobber.
#
#   - Another way to reason this:
#     - It's okay to apply more than one version tag to the same commit.
#     - It's not okay to have more than one commit with the same version.
#       - Git won't let this happen in the same repo anyway,
#         but it could happen between two separate repos.
#       - If app sees this, it'll fail to user to resolve the conflict.

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

git_smallest_version_tag () {
  local since_commit="$1"

  local smallest_patch="$( \
    git tag -l --contains "${since_commit}" "[0-9]*" "v[0-9]*" \
      | command grep -E -e "${GITSMART_RE_VERSPARTS}" \
      | command sort -V \
      | command head -n1
  )"

  # This is *ridonkulous*.
  local smallest_including_alpha="$( \
    git tag -l --contains "${since_commit}" "${smallest_patch}*" "v${smallest_patch}*" \
      | command grep -E -e "${GITSMART_RE_VERSPARTS}" \
      | command grep -E -v "^${smallest_patch}$" \
      | command perl -ne "print if s/${GITSMART_RE_VERSPARTS}/\6, \7, \2.\3.\5\6\7/" \
      | command sed '/^$/d' \
      | command sort -k1,1 -k2,2n \
      | command head -n1 \
      | command sed -E "s/^[^,]*, [^,]*, //"
  )"

  local smallest_version="${smallest_including_alpha}"
  [ -n "${smallest_version}" ] || smallest_version="${smallest_patch}"

  printf "%s" "${smallest_version}"
}

insist_prev_version_lt_later_version () {
  local prev_version="$1"
  local later_version="$2"
  local tag_commit="$3"

  if [ -z "${later_version}" ]; then
    return 0
  fi

  if [ "${prev_version}" = "${later_version}" ]; then
    >&2 echo "ERROR: Version ‚Äú${prev_version}‚Äù already exists."

    exit 1
  fi

  # 'pep440cmp' is optional, but we can do this without it.

  local prev_patch="$( \
    command perl -pe "s/${GITSMART_RE_VERSPARTS}/\2.\3.\5/" <<<"${prev_version}"
  )"

  local later_patch="$( \
    command perl -pe "s/${GITSMART_RE_VERSPARTS}/\2.\3.\5/" <<<"${later_version}"
  )"

  if [ "${prev_patch}" != "${later_patch}" ]; then
    local smaller_patch="$( \
      echo -e "${prev_patch}\n${later_patch}" \
        | command sort -V \
        | command head -n1
    )"

    if [ "${smaller_patch}" = "${prev_patch}" ]; then
      return 0
    fi
  else
    local smaller_version="$(print_smaller_vers_for_same_patch "${prev_version}" "${later_version}")"

    if [ "${smaller_version}" = "${prev_version}" ]; then
      return 0
    fi
  fi

  >&2 echo "ERROR: Cannot apply version to older commit larger than later version."
  >&2 echo "- Apply version: ‚Äú${prev_version}‚Äù"
  >&2 echo "- Target commit: ‚Äú${tag_commit}‚Äù"
  >&2 echo "- Conlicts with: ‚Äú${later_version}‚Äù (Smallest version after commit)"

  exit 1
}

insist_prev_version_gt_earlier_version () {
  local prev_version="$1"
  local earlier_version="$2"
  local tag_commit="$3"

  # Not necessary/won't hit, because `insist_prev_version_lt_later_version`
  # did it first. But just so you know this case won't happen.
  #
  if [ "${prev_version}" = "${earlier_version}" ]; then
    >&2 echo "ERROR: Version ‚Äú${prev_version}‚Äù already exists."

    exit 1
  fi

  # 'pep440cmp' is optional, but we can do this without it.

  local prev_patch="$( \
    command perl -pe "s/${GITSMART_RE_VERSPARTS}/\2.\3.\5/" <<<"${prev_version}"
  )"

  local earlier_patch="$( \
    command perl -pe "s/${GITSMART_RE_VERSPARTS}/\2.\3.\5/" <<<"${earlier_version}"
  )"

  if [ "${prev_patch}" != "${earlier_patch}" ]; then
    local smaller_patch="$( \
      echo -e "${prev_patch}\n${earlier_patch}" \
        | command sort -V \
        | command head -n1
    )"

    if [ "${smaller_patch}" = "${earlier_patch}" ]; then
      return 0
    fi
  else
    local smaller_version="$(print_smaller_vers_for_same_patch "${prev_version}" "${earlier_version}")"

    if [ "${smaller_version}" = "${earlier_version}" ]; then
      return 0
    fi
  fi

  >&2 echo "ERROR: Cannot apply version to older commit smaller than earlier version."
  >&2 echo "- Apply version: ‚Äú${prev_version}‚Äù"
  >&2 echo "- Target commit: ‚Äú${tag_commit}‚Äù"
  >&2 echo "- Conlicts with: ‚Äú${earlier_version}‚Äù (Largest version before commit)"

  exit 1
}

# ***

# Assumes version through patch level matches, so that it can sort by pre-release parts.
print_smaller_vers_for_same_patch () {
  local prev_version="$1"
  local later_version="$2"

  echo -e "${prev_version}\n${later_version}" \
    | command perl -ne "print if s/${GITSMART_RE_VERSPARTS}/\6, \7, \2.\3.\5\6\7/" \
    | command sed '/^$/d' \
    | command sort -k1,1r -k2,2n \
    | command head -n1 \
    | command sed -E "s/^[^,]*, [^,]*, //"
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

git_wip_commit_if_untidy () {
  local wipped=false

  # If nothing is staged, git-commit fails, but we'll check git-status anyway.
  test -n "$(git status --porcelain=v1)" \
    && git add -A \
    && git commit -q --no-verify -m 'PRIVATE: WIP [git-bump-version-tag]' > /dev/null \
    && wipped=true

  printf "%s" "${wipped}"
}

git_pop_wip_commit_maybe () {
  local wipped="$1"

  ${wipped} && git reset -q --mixed @~1
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

git_bump_tag_vers_push () {
  # Passed args ($@) from CLI will be passed to and parsed by
  # must_resolve_new_version_tag.

  # Remind user if they're dry-running.
  ${DRY_RUN} && echo "# TEST AHOY! (DRY_RUN=true)"

  # ***

  # Insist run from within a Git project.
  git_insist_git_repo || exit 1

  # Create temporary WIP commit if untidy.
  _WIPPED="$(git_wip_commit_if_untidy)"

  # ***

  # Note that git-smart returns the latest version-looking tag.
  # - It's not guaranteed to be SemVer compliant.
  local curr_version="$(git_largest_version_tag)"

  local VERSION_TAG=""
  local ACTION_DELETE=false
  local ACTION_PUSH=false
  local REMOTE_NAME=""
  local TAG_COMMIT=""
  # If version specified, fails if not greater than current version.
  # If bump args specified, fails on args error.
  must_resolve_new_version_tag "${curr_version}" "$@"

  # ***

  local remote_name="${REMOTE_NAME}"

  # Unless skipping remote push, warn if no remote; maybe fetch;
  # and recalculate next version if new version tag was fetched.
  if [ "${remote_name}" != "${BUMP_SKIP_REMOTE}" ]; then
    # Default to the remote tracking branch remote, or fallback to "origin".
    [ -z "${remote_name}" ] && remote_name="$(git_upstream_parse_remote_name)"
    [ -z "${remote_name}" ] && remote_name="origin"

    # We don't necessarily care if the remote doesn't exist ‚Äî we could still
    # tag the local branch, and then fail on/before the git-push ‚Äî but this
    # also seems like an issue the user should be made to resolve first. If
    # they really don't care, they can re-run the command with "-" as the
    # remote name to skip remote functionality. But really they'll probably
    # want to fix the local repo remote, or fix their bump-version-tags arg.
    must_remote_exists "${remote_name}"

    # Fetch remote at least every hour (network call).
    periodically_fetch "${remote_name}"

    local postfetch_curr_version="$(git_largest_version_tag)"

    if [ "${postfetch_curr_version}" != "${curr_version}" ]; then
      curr_version="${postfetch_curr_version}"

      # We fetched tags from the remote and found a more recent
      # latest tag, so reapply the bump options to the actual
      # latest version.
      must_resolve_new_version_tag "${curr_version}" "$@"
    fi
  fi

  # ***

  # Insist remote/branch HEAD unversioned or matches desired.
  local remote_branch
  if [ "${remote_name}" != "${BUMP_SKIP_REMOTE}" ]; then
    remote_branch="$(print_git_remote_default_branch_name "${remote_name}")" \
      || exit 1

    ${DRY_RUN} && echo "Remote: ${remote_name}/${remote_branch}"
  fi

  # ***

  # Suss tag_commit from local_head_sha and remote_head_sha.

  local tag_commit="${TAG_COMMIT}"

  local remote_head_sha
  if [ "${remote_name}" != "${BUMP_SKIP_REMOTE}" ]; then
    remote_head_sha="$(
      git_remote_branch_object_name "${remote_name}" "${remote_branch}"
    )"
  fi

  if [ -z "${tag_commit}" ]; then
    if [ "${remote_name}" != "${BUMP_SKIP_REMOTE}" ]; then
      tag_commit="${remote_head_sha}"
    else
      tag_commit="HEAD"
    fi
  fi

  local local_head_sha="$(git_HEAD_commit_sha)"

  if [ "${tag_commit}" = "HEAD" ]; then
    if [ "${remote_name}" != "${BUMP_SKIP_REMOTE}" ]; then
      # Ensure branch names match (don't let user accidentally tag and
      # push wrong branch to remote).
      local local_branch="$(git_branch_name)"

      if [ "${local_branch}" != "${remote_branch}" ]; then
        >&2 echo "ERROR: Expected the same local and remote branch names"
        >&2 echo "- Not ‚Äú${local_branch}‚Äù (local) and ‚Äú${remote_branch}‚Äù (remote)"

        exit 1
      fi
    fi

    # Optional: git-put-wise scope logic.
    if ! command -v identify_scope_ends_at > /dev/null; then
      tag_commit="${local_head_sha}"
    else
      # Exclude latest commits whose messages start with "PRIVATE: " or
      # "PROTECTED: ". Use case: So you can keep some stuff private to
      # your local repo without needing to maintain a separate feature
      # branch.
      tag_commit="$( \
        identify_scope_ends_at "^${SCOPING_PREFIX}" "^${PRIVATE_PREFIX}" \
      )"
    fi
  fi

  local default_tag_commit="${tag_commit}"

  # ***

  push_or_delete

  if ${ACTION_DELETE} && ${ACTION_PUSH}; then
    ACTION_DELETE=false
    # ACTION_PUSH=false

    tag_commit="${default_tag_commit}"

    push_or_delete
  fi

  # ***

  git_pop_wip_commit_maybe "${_WIPPED}"
}

# ***

push_or_delete () {
  local skip_push_branch=true

  if ! ${ACTION_DELETE}; then
    # Sets skip_push_branch and curr_version.
    prepare_push

    # Tag the local commit (returns immediately if already tagged).
    git_tag_local_add "${VERSION_TAG}" "${tag_commit}" "${curr_version}"
  else
    # Set tag_commit to tag commit ID, which we pass to remote delete tag
    # so it can check for conflict (not that it really matters on delete,
    # but could be interesting to user).
    tag_commit="$(git_tag_commit_object "${VERSION_TAG}")"
  fi

  if [ "${remote_name}" != "${BUMP_SKIP_REMOTE}" ]; then
    # Delete and/or push the remote tag (and maybe the branch).
    git_tag_remote_push "${VERSION_TAG}" "${tag_commit}" \
      "${remote_name}" "${remote_branch}" "${skip_push_branch}"
  fi

  # Delete locally last, so user doesn't abandon remote tag
  # (well, abandon until the next pull).
  if ${ACTION_DELETE}; then
    git_tag_local_delete "${VERSION_TAG}"
  fi
}

# ***

prepare_push () {
  skip_push_branch=false

  if [ "${remote_name}" != "${BUMP_SKIP_REMOTE}" ]; then
    if [ "${tag_commit}" = "${remote_head_sha}" ]; then
      # Don't need to push this commit, which is remote branch HEAD.
      skip_push_branch=true
    fi
  fi

  # *** Normalize the version

  VERSION_TAG="$(normalize_version "${VERSION_TAG}")"

  # *** Verify version order integrity between commits before and commits after

  # Verify tag_commit not versioned, or same as ${VERSION_TAG}.
  local commit_version="$(git_largest_version_tag --points-at ${tag_commit})"
  if [ -n "${commit_version}" ]; then
    if [ "${commit_version}" != "${VERSION_TAG}" ]; then
      local refname="${tag_commit}"
      [ "${remote_name}" != "${BUMP_SKIP_REMOTE}" ] \
        && refname="${remote_name}/${remote_branch}"

      >&2 echo "ERROR: Commit ‚Äú${refname}‚Äù is already versioned (${commit_version})," \
        "and different than new version (${VERSION_TAG})"

      exit 1
    fi

    # So that git_tag_local_add doesn't add same tag again.
    curr_version="${commit_version}"
  else
    if [ "${tag_commit}" = "${local_head_sha}" ]; then
      insist_next_version_gt_curr_version "${VERSION_TAG}" "${curr_version}" "${tag_commit}"
    else
      # Means we're tagging an old commit.
      # MEH: I don't know why we support this. Maybe I just wanted to
      #      write hundreds of lines of more code to maintain.
      # - Seems like a weird use case to support: Tagging old commit.

      local latest_smallest_version
      # This includes ${tag_commit} tags, but we checked that case
      # earlier, so we know ${tag_commit} is not versioned here.
      latest_smallest_version="$(git_smallest_version_tag "${tag_commit}")"
      insist_prev_version_lt_later_version \
        "${VERSION_TAG}" "${latest_smallest_version}" "${tag_commit}"

      local earlier_largest_version="$(git_largest_version_tag --no-contains ${tag_commit})"
      insist_prev_version_gt_earlier_version \
        "${VERSION_TAG}" "${earlier_largest_version}" "${tag_commit}"
    fi
  fi

  insist_tag_commit_unversioned_or_same_version "${VERSION_TAG}" "${tag_commit}"

  # *** Verify version order integrity between local and remote repos

  if [ "${remote_name}" != "${BUMP_SKIP_REMOTE}" ]; then
    if ! ${skip_push_branch}; then
      # We know ${tag_commit} != ${remote_head_sha} because ! ${skip_push_branch}.

      # Check if the local branch has more commits than the remote branch.
      if ! git merge-base --is-ancestor ${tag_commit} ${remote_head_sha}; then
        # Local ahead of remote.
        if ! git merge-base --is-ancestor ${remote_head_sha} ${tag_commit}; then
          >&2 echo "ERROR: Remote branch HEAD and target commit not in same branch"

          exit 1
        fi
      fi
      # else, remote ahead of local. Means we're tagging an old commit.
    fi
    # else, means we're not moving remote branch HEAD.
  fi
}

# ***

# Normalize the version otherwise a tool such as poetry-dynamic-versioning
# might impress upon the build a version slightly different than what you
# set. E.g., it'll change 1.1.1-a-1 to 1.1.1-a.1.
#
# dunamai version styles:
# - PEP 440
#   https://www.python.org/dev/peps/pep-0440
# - Semantic Versioning
#   https://semver.org)
# - Haskell Package Versioning Policy
#   https://pvp.haskell.org
#
# https://github.com/mtkennerly/poetry-dynamic-versioning
# https://github.com/mtkennerly/dunamai

normalize_version () {
  local orig_version="$1"

  # `dunamai from git --style`: [--style {pep440,semver,pvp}]
  local normal_style="semver"

  if [ -f "$(git_project_root)/pyproject.toml" ]; then
    normal_style="pep440"
  fi

  local normal_vers
  normal_vers="$(normalize_version_with_style "${VERSION_TAG}" "${normal_style}")"

  # Unnecessary double-check (before adding dunamai and PEP440 support, this
  # script was the SemVer style enforcer; but now dunamai is in charge, so
  # this check should never fail, and is being included mostly out of
  # curiosity, but also as an excuse not to delete the callee).
  if [ "${normal_style}" = "semver" ] \
    && (! ${ACTION_DELETE} || ${ACTION_PUSH}) \
  ; then
    insist_new_version_semver_compliant "${VERSION_TAG}"
  fi

  if [ "${normal_vers}" != "${VERSION_TAG}" ]; then
    if git_bump_confirm_normalize "${VERSION_TAG}" "${normal_vers}"; then
      VERSION_TAG="${normal_vers}"
    fi
  fi

  printf "%s" "${VERSION_TAG}"
}

normalize_version_with_style () {
  local orig_version="$1"
  local normal_style="$2"

  local prefixed_version="${orig_version}"
  if [ "${orig_version}" = "${orig_version#v}" ]; then
    prefixed_version="v${orig_version}"
  fi

  local temp_dir="$(mktemp -d /tmp/$(basename $0)-XXXXXXX)"
  [ ! -d "${temp_dir}" ] && >&2 echo "ERROR: \`mktemp\` failed" && exit 1 || true

  cd "${temp_dir}"

  git init . -q
  touch foo
  git add foo
  git commit -m foo -q
  git tag "${prefixed_version}"

  # The two styles we support:
  #  dunamai from git --style semver
  #  dunamai from git --style pep440
  dunamai from git --style "${normal_style}"

  cd - > /dev/null

  # DEV: Uncomment to leave temp dir:
  #
  #   >&2 echo "${temp_dir}"
  #   exit 1

  /bin/rm -rf "${temp_dir}"
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

_WIPPED=false

function exit_cleanup () {
  git_pop_wip_commit_maybe "${_WIPPED}"
}
trap exit_cleanup EXIT

# ***

main () {
  source_deps "${BASH_SOURCE[0]}" || exit 1

  git_bump_tag_vers_push "$@"
}

if [ "$0" = "${BASH_SOURCE[0]}" ]; then
  main "${@}"
fi

# Unhook exit_cleanup.
trap - EXIT

