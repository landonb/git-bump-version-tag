#!/usr/bin/env bash
# vim:tw=0:ts=2:sw=2:et:norl:ft=bash
# Author: Landon Bouma (landonb &#x40; retrosoft &#x2E; com)
# Project: https://github.com/landonb/git-bump-version-tag#üê´
# Copyright ¬© 2020 Landon Bouma. All rights reserved.
# License: MIT. Please find more in the LICENSE file.

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

# DUNNO/2023-11-05: These values are not automatically maintained.
# - So no promises I'll keep them current...
# - For now, using ">=" in VERSION_FULL to let users know that the
#   latest code may have drifted, ha.
#
# MAYBE: Automate maintenance of these values.

VERSION="1.3.0"
VERSION_DATE="2023-11-05"
# INERT: Answer reason to add the commit SHA?
#  # The commit SHA before the update-version commit.
#  VERSION_COMMIT="e989201"

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

# YOU: Uncomment (or set from environment) for a dry run:
#  DRY_RUN=true
DRY_RUN=${DRY_RUN:-false}

BUMP_PRERELEASE_BASE="${BUMP_PRERELEASE_BASE:--alpha.}"

BUMP_REMOTE_BRANCH_NAME="${BUMP_REMOTE_BRANCH_NAME:-release}"

BUMP_VERBATIM="${BUMP_VERBATIM:-false}"

BUMP_SKIP_REMOTE="-"

# USYNC: Same environ name as what git-put-wise uses.
# CXREF: https://github.com/DepoXy/git-put-wise#ü•®
#   ~/.kit/git/git-put-wise/lib/common_put_wise.sh
#
#  SCOPING_PREFIX="${SCOPING_PREFIX:-PROTECTED: }"
#  PRIVATE_PREFIX="${PRIVATE_PREFIX:-PRIVATE: }"

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

CACHE_PROG_NAME="git-bump-version-tag"

PROG_NAME="$(basename "$0")"

# E.g., "git-bump-version-tag 1.0.0 2023-11-05"
#
# - MAYBE/2023-11-05: See comment above: Until automated, the version
#   and date values might have become stale. So we're using ">=" to
#   tell the user that these values might have drifted, e.g.,
#
#     "git-bump-version-tag >= 1.0.0 2023-11-05"
#
#   - NTHEN: After automating VERSION and VERSION_DATE, reset this string:
#
#       VERSION_FULL="${PROG_NAME} ${VERSION} ${VERSION_DATE}"
#
VERSION_FULL="${PROG_NAME} >= ${VERSION} ${VERSION_DATE}"

# Used by print_current_project_version_with_head_distance.
VERSION_DISTANCE_SYMBOL="${VERSION_DISTANCE_SYMBOL:- üîª}"
# ***

USAGE="\
USAGE: ${PROG_NAME} [ACTIONS...] [OPTIONS...] [<VERSIONTAG>] [--] [<REMOTE>] [<COMMIT>]

ACTIONS:

  Combine one or more bump actions:

    M|-M|major
    m|-m|minor
    p|-p|patch
    a|-a|alpha
    l|-l|least
    s|-s|same

  Or specify a different action:

    d|-d|delete
    P|-P|push
    c|-c|current
    version|--version

OPTIONS:

  Optional bump action options:

    v|-v|v-pre
    V|-V|v-del


DETAILS
~~~~~~~

- BUMP ACTIONS:

    M, -M, major   Bump major version by one

    m, -m, minor   Bump minor version by one

    p, -p, patch   Bump patch version by one

    a, -a, alpha   Bump pre-release version by one
                   - This only works if the pre-release part ends in a number
                   - Use BUMP_PRERELEASE_BASE to set the default prerelease
                     value (defaults: ‚Äú${BUMP_PRERELEASE_BASE}‚Äù)
                     - E.g., given current version 1.2.3, then
                         $ git bump major alpha
                       will create version 2.0.0${BUMP_PRERELEASE_BASE}1
                     - BUMP_PRERELEASE_BASE is ignored if the previous tag
                       is already pre-release, and its value is used instead

    l, -l, least   Bump least part by one (either patch or pre-release)

    s, -s, same    Use current version
                   - Useful if you only tagged locally,
                     and would like to push that tag now
                   - But if you didn't tag the current commit,
                     likely to fail because cannot repeat a version

  The \"least\" option will be assumed if no option and no other action
  is specified (e.g., on a bare \`${PROG_NAME}\`)

  Options can be specified individually or as a classic arg clump
  - E.g., \`git bump minor alpha\` is the same as \`git bump ma\`
  - Though beware if a clump option matches a known remote name, then it's
    assumed to be the <REMOTE> argument instead (in which case you cannot
    use the clump format)

- OTHER ACTIONS:

    d, -d, delete  Delete version tag (remote, then local)
                   - Unless specified, uses latest version
                   - Useful if you messed up ‚Äî but it's on you to ensure it's
                     not too late to delete a tag you previously published
                   - First deletes the GitHub release, if exists

    P, -P, push    Push tag (default action when not 'delete')

    c, -c, cur, --cur, current, --current
                   Show current project version number
                   - Also show ‚ñº distance from HEAD if tag on older commit

    version, --version
                   Show application (${PROG_NAME}'s) version number

- BUMP OPTIONS:

    v, -v, v-pre   Use \"v\" tag prefix
                   - Adds v-prefix if previous tag was not v-prefixed

    V, -V, v-del   Remove \"v\" tag prefix
                   - Removes v-prefix if previous tag was v-prefixed

ARGUMENTS:

  <VERSIONTAG>
            Use this to specify the next version tag explicitly
            - Useful when versioning for the first time (though
              bump specifiers will bump from 0, so they work, too)
            - Useful for specifying a uniquely-named prerelease version

  <REMOTE>  Specify which remote to use
            - If not specified, will default to the remote specified
              by the local upstream branch
            - If local branch does not have an upstream (you can set
              one via \`git branch -u <remote/branch>\`), will use
              remote from \`git remote -v\` if only one is configured
            - Specify \"-\" to skip remote tag push altogether
            - ALERT: You must use \`--\` before remote name if it
              could be interpreted as an OPTIONS sequence, or if the
              remote name is also a valid version

  <COMMIT>  Specify commit to tag, either SHA-1 hash, or \"HEAD\"
            - If not specified, defaults to remote branch HEAD commit
            - If \"HEAD\" is specified and git-put-wise is installed,
              this will tag only the most recent \"non-scoped\" local
              commit
              - A non-scoped commit is indicated by a commit message
                with a specific prefix, either PRIVATE_PREFIX (set to
                \"${PRIVATE_PREFIX:-PRIVATE: }\") or SCOPING_PREFIX (set to \"${SCOPING_PREFIX:-PROTECTED: }\")
            - If \"HEAD\", will also push latest commits to remote
              before tagging

OVERRIDES: Set these environment variables for alternative behavior:

  BUMP_PRERELEASE_BASE=\"${BUMP_PRERELEASE_BASE}\"
            Prerelease part prefix, used by a|alpha

  BUMP_REMOTE_BRANCH_NAME=\"${BUMP_REMOTE_BRANCH_NAME}\"
            Name of remote branch whose HEAD commit will be tagged,
            if unable to determine the remote branch automatically
            - By default uses the default branch for the remote for
              the local upstream branch (i.e., looks for 'HEAD branch'
              from \`git remote show <remote>\`), and this environ is
              only used if the default branch is indeterminable

  BUMP_VERBATIM=${BUMP_VERBATIM}
            If true, applies all patch options in the order encountered
            - E.g., if not verbatim, then
                $ git bump Mmp
              will only bump the largest part (major)
              - So version 1.2.3 ‚Üí 2.0.0
              - But if BUMP_VERBATIM=true, then the version
                increments 1.2.3 ‚Üí 2.0.0 ‚Üí 2.1.0 ‚Üí 2.1.1
              - As stated, the options are applied in order, so
                reversing 'Mmp' to 'pmM' would result in 2.0.0:
                  $ git bump pmM
                would bump 1.2.3 ‚Üí 1.2.4 ‚Üí 1.3.0 ‚Üí 2.0.0
            - Regardless of BUMP_VERBATIM, you are always allowed to mix
              an alpha bump with any of the other parts (major|minor|patch)
              - E.g., if at version 1.2.3, you can easily start a new alpha
                version at 1.2.4-alpha.1, 1.3.0-alpha.1, or 2.0.0-alpha.1
            - (As an aside, we're unclear if BUMP_VERBATIM is very useful)

  SCOPING_PREFIX=\"${SCOPING_PREFIX:-PROTECTED: }\"
  PRIVATE_PREFIX=\"${PRIVATE_PREFIX:-PRIVATE: }\"
            Specifies the commit message prefixes that designate which
            commits should not be published
            - Used when <COMMIT> is specified as \"HEAD\"
            - Only works if git-put-wise is installed
              (see note under <COMMIT>, above)
              - You can find git-put-wise at
                https://github.com/DepoXy/git-put-wise#ü•®

${VERSION_FULL}"

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

source_deps () {
  # Optional: 'pep440cmp'.
  # https://github.com/hotoffthehamster/pep440-version-compare-cli

  # Need Dunamai to normalize for SemVer or PEP 440.
  # CXREF: https://github.com/mtkennerly/dunamai
  insist_cmd 'dunamai'

  # Need Perl for fancy SemVer regex.
  insist_cmd 'perl'

  # Ensure coreutils installed (from Linux pkg. mgr., or from macOS Homebrew).
  insist_cmd 'realpath'

  # Load ask_yesnoskip.
  # https://github.com/landonb/sh-ask-yesnoskip
  . "$(dirname "$(realpath "$0")")/../deps/sh-ask-yesnoskip/bin/ask-yesnoskip.sh"

  # Load git_* functions, including
  #   git_branch_name
  #   git_insist_git_repo
  #   git_largest_version_tag
  #   git_remote_exists
  #   git_versions_tagged_for_commit_object
  #   git_tag_remote_verify_commit;
  # and load environs, incl. GITSMART_RE_VERSPARTS, GITSMART_RE_SEMVERSPARTS.
  # CXREF: https://github.com/landonb/sh-git-nubs
  #   ~/.kit/sh/sh-git-nubs/bin/git-nubs.sh
  . "$(dirname "$(realpath "$0")")/../deps/sh-git-nubs/bin/git-nubs.sh"

  # Optional: git-put-wise, for 'identify_scope_ends_at'.
  # https://github.com/DepoXy/git-put-wise#ü•®
  if command -v git-put-wise > /dev/null; then
    local put_wise_bin="$(dirname "$(realpath "$(command -v git-put-wise)")")"
    . "${put_wise_bin}/../lib/common_put_wise.sh"
    . "${put_wise_bin}/../lib/dep_apply_confirm_patch_base.sh"
  fi
}

insist_cmd () {
  local cmdname="$1"

  command -v "${cmdname}" > /dev/null && return || true

  >&2 echo "ERROR: Missing system command ‚Äò${cmdname}‚Äô."

  exit_1
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

print_git_remote_default_branch_name () {
  local remote_name="$1"

  local branch_names num_branches remote_branch

  # If remote only has one branch, use it.
  branch_names="$(git branch -a --list "${remote_name}/*")"
  num_branches="$(echo "${branch_names}" | wc -l)"

  if [ ${num_branches} -eq 0 ]; then
    >&2 echo "ERROR: No local branches found for remote '${remote_name}'." \
      "Perhaps you need to fetch?"

    exit_1
  fi

  if [ ${num_branches} -eq 1 ]; then
    remote_branch="$(echo "${branch_names}" | sed 's#^.*/##')"
  else
    # Note that git_remote_default_branch is a network call (git remote show),
    # so we try to avoid it. Above, we checked if remote only has one branch.
    # Here we know there are multiple branches.
    # - One last resort to avoid network call: Check environ "config" value.
    branch_names="$(git branch -a --list "${remote_name}/${BUMP_REMOTE_BRANCH_NAME}")"
    if [ -n "${branch_names}" ]; then
      remote_branch="$(echo "${branch_names}" | sed 's#^.*/##')"
    else
      # ALERT: Network call.
      remote_branch="$(git_remote_default_branch "${remote_name}")"
    fi
  fi

  # Shouldn't happen, we assume.
  if [ -z "${remote_branch}" ]; then
    >&2 echo "FATAL: Where's remote branch?"

    exit_1
  fi

  printf "%s" "${remote_branch}"
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

must_remote_exists () {
  local remote_name="$1"

  git_remote_exists "${remote_name}" && return || true

  >&2 echo "ERROR: No remote named ‚Äú${remote_name}‚Äù"

  exit_1
}

# Some CI workflows might version tag automatically,
# so periodically fetch to try to ensure up to date.
# - We could fetch every time, but this is a network
#   operation, and sometimes you're too in the zone
#   to be bothered.
# - MAYBE: Is there a better approach to gating `fetch`?
periodically_fetch () {
  local remote_name="$1"

  # E.g., "tools.git-bump-version-tag".
  BUMP_CONFIG_SECTION="tools.${CACHE_PROG_NAME}"
  BUMP_CONFIG_LAST_FETCH="lastfetch"

  local last_update="$(git config ${BUMP_CONFIG_SECTION}.${BUMP_CONFIG_LAST_FETCH})"

  local do_fetch=true

  if [ -n "${last_update}" ]; then
    if [ ${last_update} -gt $(date -d '-1 hour' +'%s') ]; then
      do_fetch=false
    fi
  fi
  
  if ${do_fetch}; then
    # We could `git fetch "${remote_name}" --tags` get tags only,
    # but should update default branch, too.
    git fetch "${remote_name}"

    git config ${BUMP_CONFIG_SECTION}.${BUMP_CONFIG_LAST_FETCH} "$(date +%s)"
  fi
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

parse_version_parts () {
  local curr_version="$1"

  # See also: GITSMART_RE_SEMVERSPARTS. Here we use looser regex so we
  # can read any style version and increment any part of it. Then later
  # we'll use the dunamai library to normalize the version according to
  # style.

  # Note the '!' in '\1!', so that `read` parses the string correctly when
  # there is no v-prefix (i.e., ensure there's a word there for `read`).
  # - Use perl, not sed, because there's a Perl-only .*? non-greedy in the regex.
  partsstr="$(
    command perl -pe "s/${GITSMART_RE_VERSPARTS}/\1! \2 \3 \5 \6 \7/" <<<"${curr_version}"
  )"

  echo "${partsstr}"
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

must_resolve_new_version_tag () {
  local curr_version="$1"
  shift

  # Sets VERSION_TAG and ACTION_DELETE,
  # and maybe REMOTE_NAME, and/or TAG_COMMIT.
  resolve_version_bump "${curr_version}" "$@"
}

# ***

resolve_version_bump () {
  local curr_version="$1"
  shift

  local partsstr
  partsstr="$(parse_version_parts "${curr_version}")"

  local vprefix major minor patch prerelease finalnum

  IFS=' ' read vprefix major minor patch prerelease finalnum <<< "${partsstr}"

  # ${DRY_RUN} && echo "read: v:${vprefix} M:${major} m:${minor}" \
  #   "p:${patch} a:${prerelease} n:${finalnum} (${partsstr})" || true

  local was_prerelease=$(test -n "${prerelease}" && echo true || echo false)

  # Strip the '!' from the v-prefix (which was used to support `read`).
  vprefix="${vprefix%!}"

  local bumped_patch_or_better=false
  local bmajor=false bminor=false bpatch=false balpha=false
  local bump_verbatim="${BUMP_VERBATIM:-false}"
  local bumps_count=0

  add_prefix () {
    vprefix="v"
  }

  del_prefix () {
    vprefix=""
  }

  bump_bumps_count () {
    let 'bumps_count += 1'
  }

  bump_major () {
    bump_bumps_count
    ! ${bump_verbatim} && bmajor=true && return || true

    # Note that if var. unset, the let += 1 sets it to 1.
    let 'major += 1'; minor=0; patch=0; prerelease=; finalnum=;
    bumped_patch_or_better=true
  }

  bump_minor () {
    bump_bumps_count
    ! ${bump_verbatim} && bminor=true && return || true

    let 'minor += 1'; patch=0; prerelease=; finalnum=;
    bumped_patch_or_better=true
  }

  bump_patch () {
    bump_bumps_count
    ! ${bump_verbatim} && bpatch=true && return || true

    # Only bump patch if no current alpha. Otherwise just drop alpha.
    if [ -z "${prerelease}" ]; then
      let 'patch += 1'
    fi
    prerelease=
    finalnum=
    bumped_patch_or_better=true
  }

  # What SemVer calls "pre-release".
  bump_alpha () {
    bump_bumps_count
    ! ${bump_verbatim} && balpha=true && return || true

    if [ -z "${prerelease}" ]; then
      # If no current alpha, must bump patch so new version is < current vers.
      ${bumped_patch_or_better} || let 'patch += 1'
      prerelease="${BUMP_PRERELEASE_BASE:--alpha.}"
      finalnum="1"
    else
      let 'finalnum += 1'
    fi
  }

  bump_least () {
    if ${was_prerelease}; then
      bump_alpha
    else
      bump_patch
    fi
  }

  local skip_opts=0
  local n_extra_args=0

  # USYNC: version_tag_environs
  VERSION_TAG=""
  ACTION_DELETE=false
  ACTION_PUSH=false
  REMOTE_NAME=""
  TAG_COMMIT=""

  local ACTION_SAME=false
  local VERSION_ARG=""

  while [ -n "$1" ]; do
    local cur_arg="$1"
    shift

    if [ ${skip_opts} -gt 0 ]; then
      if [ ${skip_opts} -eq 1 ]; then
        if is_known_remote "${cur_arg}"; then
          skip_opts=2

          REMOTE_NAME="${cur_arg}"
        elif is_known_commit_sha "${cur_arg}"; then
          skip_opts=3

          TAG_COMMIT="${cur_arg}"
        else
          >&2 echo "ERROR: Expected <REMOTE> or <COMMIT>, not: ‚Äú${cur_arg}‚Äù"

          exit_1
        fi
      elif [ ${skip_opts} -eq 2 ]; then
        skip_opts=3

        if is_known_commit_sha "${cur_arg}"; then
          TAG_COMMIT="${cur_arg}"
        else
          >&2 echo "ERROR: Expected <COMMIT>, not: ‚Äú${cur_arg}‚Äù"

          exit_1
        fi
      else
        # Case: [ ${skip_opts} -ge 3 ]
        >&2 echo "ERROR: Unrecognized argument: ‚Äú${cur_arg}‚Äù"
        >&2 echo "- Or maybe you specified more than one"
        >&2 echo "   <VERSIONTAG>, <REMOTE>, or <COMMIT>"

        exit_1
      fi
    elif [ "${cur_arg}" = '--' ]; then
      skip_opts=1
    elif like_a_version "${cur_arg}"; then
      skip_opts=1

      VERSION_ARG="${cur_arg}"
    elif is_known_remote "${cur_arg}"; then
      skip_opts=2

      REMOTE_NAME="${cur_arg}"
    elif is_known_commit_sha "${cur_arg}"; then
      skip_opts=3

      TAG_COMMIT="${cur_arg}"
    else
      case "${cur_arg}" in
        s | -s | same)
          ACTION_SAME=true
          VERSION_TAG="${curr_version}"
          ;;
        d | -d | delete)
          ACTION_DELETE=true
          VERSION_TAG="${curr_version}"
          ;;
        P | -P | push)
          ACTION_PUSH=true
          ;;
        h | -h | help | --help)
          echo "${USAGE}"

          exit_0
          ;;
        c | -c | cur | --cur | current | --current)
          # The currect project version.
          print_current_project_version_with_head_distance

          exit_0
          ;;
        version | --version)
          # The git-bump-version-tag version.
          echo "${VERSION_FULL}"

          exit_0
          ;;
        M | -M | major) bump_major ;;
        m | -m | minor) bump_minor ;;
        p | -p | patch) bump_patch ;;
        a | -a | alpha) bump_alpha ;;
        l | -l | least) bump_least ;;
        v | -v | v-pre) add_prefix ;;
        V | -V | v-del) del_prefix ;;
        *)
          for char in $(echo "${cur_arg#-}" | sed -E -e 's/(.)/\1\n/g'); do
            case ${char} in
              s) ACTION_SAME=true;
                 VERSION_TAG="${curr_version}" ;;
              d) ACTION_DELETE=true;
                 VERSION_TAG="${curr_version}" ;;
              P) ACTION_PUSH=true ;;
              M) bump_major ;;
              m) bump_minor ;;
              p) bump_patch ;;
              a) bump_alpha ;;
              l) bump_least ;;
              v) add_prefix ;;
              V) del_prefix ;;
              *)
                >&2 echo "ERROR: Unrecognized argument: ‚Äú${cur_arg}‚Äù"

                exit_1
                ;;
            esac
          done
      esac
    fi
  done

  if [ -n "${VERSION_TAG}" ]; then
    # Means 'same' and/or 'delete' specified.
    if [ ${bumps_count} -gt 0 ]; then
      >&2 echo "ERROR: Cannot indicate bump (M|m|p|a), and pick 'same' (s) or delete (d)."

      exit_1
    elif ${ACTION_SAME} && [ -n "${VERSION_ARG}" ]; then
      >&2 echo "ERROR: Cannot indicate 'same' (s), and specify <VERSIONTAG>."

      exit_1
    fi
  fi

  if [ -n "${VERSION_ARG}" ]; then
    # Means <VERSIONTAG> specified.
    if [ ${bumps_count} -gt 0 ]; then
      >&2 echo "ERROR: Cannot indicate bump (M|m|p|a), and specify <VERSIONTAG>."

      exit_1
    fi
    # else, we already checked not 'same' and <VERSIONTAG> specified.
    # - But if 'delete' specified, be sure to delete <VERSIONTAG>.

    VERSION_TAG="${VERSION_ARG}"
  fi

  if [ -z "${VERSION_TAG}" ]; then
    if ${bump_verbatim}; then
      # We default bump_verbatim=false, so this means user called us w/
      # BUMP_VERBATIM=true. And if they didn't specify an action (they
      # called `BUMP_VERBATIM=true git bump`), nothing happened, and
      # usage says we default to 'least' action.
      bump_least
    else
      # Ugh, apologies for such a long branch... and long function.
      if [ ${bumps_count} -eq 0 ]; then
        # No action (user called naked `git bump-version-tag`). Usage says
        # defaults 'least'. We do it now while bump_verbatim still false.
        bump_least
      fi

      bump_verbatim=true

      # We could let user bump more than one part, e.g.,
      #
      #   ! ${bmajor} || bump_major
      #   ! ${bminor} || bump_minor
      #   ! ${bpatch} || bump_patch
      #   ! ${balpha} || bump_alpha
      #
      # but that's what VERBATIM_BUMP=true is for: to let
      # user specify their own bump recipe, and we play
      # along.
      #
      # But for most users, we'll be strict and assume
      # they only want to bump on component (like, why
      # do you want to skip versions? If if that's what
      # you really want, use VERBATIM_BUMP).

      local warn_too_many=false
      # BWARE: If `let` result is 0, function exits nonzero.
      # - I.e., this would trigger errexit if bumps_count=1:
      #     ! ${balpha} || let 'bumps_count -= 1'
      ${balpha} && let 'bumps_count -= 1' || true
      [ ${bumps_count} -le 1 ] || warn_too_many=true

      bumps_count=0

      local biggest=""

      # Idea here is we only honor bumping single component.
      if ${bmajor}; then
        bump_major
        biggest="major"
      elif ${bminor}; then
        bump_minor
        biggest="minor"
      elif ${bpatch}; then
        bump_patch
        biggest="patch"
      fi

      # User can always mix alpha bump with any previous bump,
      # so they can easily create next version alpha release.
      if ${balpha}; then
        bump_alpha
        # We'd never use this `biggest`.
        #  biggest="prerelease"
      fi

      if [ ${bumps_count} -eq 0 ]; then
        # Should be impossible path, because bump_least above if ${bumps_count} -eq 0.
        >&2 echo "ERROR: Please specify a bump part (M|m|p|a|l) or choose same (s)."

        exit_1
      elif ${warn_too_many}; then
        >&2 echo "WARNING: Only the biggest non-alpha bump option will be used (${biggest})."
        >&2 echo "- If you want to bump more than one part, toggle \`BUMP_VERBATIM=true\`"
        # Otherwise don't specify more than one part (and no need to make this
        # warning message optional).
      fi
    fi

    pdot=""
    [ -z "${patch}" ] || pdot="."

    # ${DRY_RUN} && echo "version_tag: v:${vprefix} M:${major:-0} m:${minor:-0}" \
    #   "?:${pdot} p:${patch} a:${prerelease} n:${finalnum}" || true
    version_tag="${vprefix}${major:-0}.${minor:-0}${pdot}${patch}${prerelease}${finalnum}"

    VERSION_TAG="${version_tag}"
  fi

  ${DRY_RUN} && echo "VERSION_TAG=${VERSION_TAG}" || true
}

like_a_version () {
  local word="$1"

  echo "${word}" | command grep -q -E "${GITSMART_RE_VERSPARTS}"
}

is_known_remote () {
  local word="$1"

  # "-" means skip remote tag push.
  [ "${word}" = "${BUMP_SKIP_REMOTE}" ] && return 0 || true

  starts_with_alphanum "${word}" || return 1

  git remote get-url "${word}" > /dev/null 2>&1
}

is_known_commit_sha () {
  local word="$1"

  starts_with_alphanum "${word}" || return 1

  [ "${word}" = "HEAD" ] && return 0 || true

  git rev-parse "${word}" > /dev/null 2>&1 || return 1

  [[ "$(git rev-parse "${word}")" = "${word}"* ]]
}

# - A hostname may not start with a hyphen:
#     <name>  ::= <let>[*[<let-or-digit-or-hyphen>]<let-or-digit>]
#   https://www.rfc-editor.org/rfc/rfc952
#   - A hostname may start with an alpha or a digit:
#     https://www.rfc-editor.org/rfc/rfc1123#section-2
# - Same with SHA, starts with alphanum. No biblio needed.
starts_with_alphanum () {
  local word="$1"

  echo "${word}" | command grep -q -E -e "^[a-zA-Z0-9]+$"
}

# ***

print_current_project_version_with_head_distance () {
  local curr_version_commit
  local curr_vers_obj_short
  local curr_vers_distance
  local curr_vers_dist_suffix=""

  curr_version_commit="$(git_tag_commit_object "${curr_version}")"
  curr_vers_obj_short="$(git_sha_shorten "${curr_version_commit}")"
  curr_vers_distance="$(git rev-list --count ${curr_version_commit}..HEAD)"

  if [ ${curr_vers_distance} -ne 0 ]; then
    curr_vers_dist_suffix="${VERSION_DISTANCE_SYMBOL}${curr_vers_distance}"
  fi

  echo "${curr_version}${curr_vers_dist_suffix}"
}

# ***

insist_next_version_gt_curr_version () {
  local next_version="$1"
  local curr_version="$2"
  local tag_commit="$3"

  local is_newer_version=true

  check_prev_version_gt_earlier_version \
    "${next_version}" "${curr_version}" "${tag_commit}" \
    > /dev/null 2>&1 \
      || is_newer_version=false

  # Optional: 'pep440cmp'
  if ! command -v pep440cmp > /dev/null; then
    if ${GIT_BUMP_VERSION_TAG_PEP400CMP_ENABLE:-false}; then
      >&2 echo "ALERT: Cannot verify next version greater than current version."
      >&2 echo "- Please install pep440cmp, e.g.,"
      >&2 echo "    pipx install pep440-version-compare-cli"
      >&2 echo "- CXREF:"
      >&2 echo "    https://github.com/hotoffthehamster/pep440-version-compare-cli"
    fi
  else
    pep440cmp "${next_version}" gt "${curr_version}" > /dev/null \
      || is_newer_version=false
  fi

  if ! ${is_newer_version}; then
    if ! ${ACTION_DELETE}; then
      >&2 echo "ERROR: Desired version not greater than current version!"
      >&2 echo "  ‚Äú${next_version}‚Äù !> ‚Äú${curr_version}‚Äù"

      exit_1
    fi

    >&2 echo
    >&2 echo "ALERT: You are deleting a version older than the current version!"
    >&2 echo
  fi
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

# CXREF: SemVer Perl regex, from the source, unaltered.
#   https://semver.org/
#   https://regex101.com/r/Ly7O1x/3/
insist_new_version_semver_compliant () {
  local version_tag="$1"

  local vless_version="$(echo "${version_tag}" | sed 's/^v//')"

  local semver
  semver="$(
    perl -ne "print if /${GITSMART_RE_SEMVERSPARTS}/" <<<"${vless_version}"
  )"

  if [ -z "${semver}" ]; then
    >&2 echo "ERROR: The new version is not SemVer compliant: ${vless_version}"
    # dunamai normalized the version value, and dunamai is never wrong
    # (so if you see this message, it's prob in GITSMART_RE_SEMVERSPARTS).
    >&2 echo "- Unexpected: You should never see this message!"

    exit_1
  fi
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

# Assume *Yes!* when called without stdin attached.
#
# - When this script is run from a terminal, stdin [ -t 0 ] is open and
#   connected to a terminal; but stdout [ -t 1 ] is not connected.
# - When tested directly from the console, both 0 & 1 are terminaled.
# - When run from GitHub Actions, neither are attached to a terminal.
# Short answer: If there's no stdin, we cannot very well be told what to do.

GIT_BUMP_INBIHIT_NO_TTY_WARNING=${GIT_BUMP_INBIHIT_NO_TTY_WARNING:-false}

ask_yesnoskip_maybe () {
  local the_ask="$1"
  local default_choice="$2"

  isa_tty () { [ -t 0 ]; }

  local retcode=0

  if isa_tty; then
    set +e
    THE_CHOICE=$(SKIP_PROMPT_NL=true ask_yesnoskip "${the_ask}" "${default_choice}")
    retcode=$?
    set -e
  else
    # Seems tedious, but we'll check if stdin has anything queued,
    # e.g., so user can pipe answers (not that I can think why anyone
    # would ever want to!). Otherwise we'll auto-yes all prompts, e.g.,
    # because user trusts us and has git-bump wired into a CI release
    # workflow.

    # WEIRD: -t 0 doesn't return anything when data being piped, e.g.,
    #   echo "N" | git bump l
    # - So use a nonzero timeout.
    local input_line
    read -t 0.01 input_line

    if [ -z "${input_line}" ]; then
      if ! ${GIT_BUMP_INBIHIT_NO_TTY_WARNING}; then
        # Only print it once.
        GIT_BUMP_INBIHIT_NO_TTY_WARNING=true

        >&2 echo "OHYEA: Enabling auto-yesser (no tty or input on stdin)"
      fi

      >&2 echo "Auto-yessing: ${the_ask}? [Y/n/s] Y"

      THE_CHOICE="y"
    else
      set +e
      THE_CHOICE=$( \
        SKIP_PROMPT_NL=true ask_yesnoskip "${the_ask}" "${default_choice}" "${input_line}"
      )
      retcode=$?
      set -e

      # Print what we read from the pipe to show input, and to wrap output.
      >&2 echo "${input_line}"
    fi
  fi

  return ${retcode}
}

git_bump_confirm_next () {
  local version_tag="$1"
  local curr_version="$2"

  local do_what_now="create first version tag at"
  if [ -n "${curr_version}" ]; then
    if [ -n "${TAG_COMMIT}" ]; then
      do_what_now="backfill tag"
    else
      do_what_now="bump ‚Äú${curr_version}‚Äù ‚Üí"
    fi
  fi

  local msg="Okay to ${do_what_now} ‚Äú${version_tag}‚Äù"

  local THE_CHOICE
  ask_yesnoskip_maybe "${msg}" "Y"

  [ $? -ne 0 ] && exit_1 || true

  [ "${THE_CHOICE}" != "y" ] && return 1 || return 0
}

git_bump_confirm_normalize () {
  local version_tag="$1"
  local normal_vers="$2"
  local normal_style="$3"

  local msg="Okay to normalize ‚Äú${version_tag}‚Äù to ‚Äú${normal_vers}‚Äù (${normal_style} style)"

  local THE_CHOICE
  ask_yesnoskip_maybe "${msg}" "Y"

  [ $? -ne 0 ] && exit_1 || true

  [ "${THE_CHOICE}" != "y" ] && return 1 || return 0
}

git_bump_confirm_delete () {
  local version_tag="$1"
  # local remote_name="$2"
  local remote_name="${2:-localhost}"

  local msg="Okay to delete ‚Äú${version_tag}‚Äù"

  if [ -n "${remote_name}" ]; then
    msg="${msg} from ‚Äú${remote_name}‚Äù"
  fi

  local THE_CHOICE
  ask_yesnoskip_maybe "${msg}" "Y"

  [ $? -ne 0 ] && exit_1 || true

  [ "${THE_CHOICE}" != "y" ] && return 1 || return 0
}

git_bump_confirm_push () {
  local version_tag="$1"
  local remote_name="$2"

  local msg="Okay to push ‚Äú${version_tag}‚Äù to ‚Äú${remote_name}‚Äù"

  local THE_CHOICE
  ask_yesnoskip_maybe "${msg}" "Y"

  [ $? -ne 0 ] && exit_1 || true

  [ "${THE_CHOICE}" != "y" ] && return 1 || return 0
}

# ***

git_bump_print_conflict_alert () {
  local version_tag="$1"
  local remote_name="$2"
  local tag_commit="$3"

  echo
  echo "üö® ATTENTION üö®: The tag ‚Äò${version_tag}‚Äô on remote ‚Äò${remote_name}‚Äô"
  echo "                 refers to a different commit than the local target:"
  echo
  echo "    target tag ref  ${tag_commit}"
  echo "    remote tag ref  ${GNUBS_TAG_COMMIT_OBJECT:-<missing-GNUBS_TAG_COMMIT_OBJECT>}"
  echo
  #
  # `git_tag_remote_verify_commit` sets a global to send back the tag commit ID.
  if [ -z "${GNUBS_TAG_COMMIT_OBJECT}" ]; then
    # Impossible path.
    >&2 echo "ERROR: Expected non-empty remote tag ref (GNUBS_TAG_COMMIT_OBJECT)"
  fi
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

echo_or_eval () {
  ${DRY_RUN} && echo "DRY_RUN: $@" || eval "$@"
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

git_tag_local_add () {
  local version_tag="$1"
  local tag_commit="$2"
  local curr_version="$3"

  if ! "${ACTION_PUSH}"; then
    if [ "${version_tag}" = "${curr_version}" ]; then
      echo "‚úì Local tag exists"

      return 0
    fi

    # Prompt user to set local tag. Returns zero on Yes, exits
    # on No, or returns nonzero on Skip. But Skip is basically
    # just graceful exit: the only operation remaining pushes
    # the local tag to the remote, but there's no local tag, so.
    git_bump_confirm_next "${version_tag}" "${curr_version}" \
      || exit_1
  fi

  # Note that this command tags HEAD, as opposed to a specific branch.
  # E.g., we could tag, say, the release branch:
  #   git tag -a ${version_tag} -m "Version: ${version_tag}" "release"
  # but that would probably be confusing to the user. So stick to HEAD.

  insist_git_user_configured

  echo_or_eval git tag -a "${version_tag}" -m "'Version: ${version_tag#v}'" "${tag_commit}"

  echo "‚úì Created local tag"
}

# ***

# When run from CI, Git user unset by default. Up to caller
# (GHA workflow) to set user.email and user.name.
insist_git_user_configured () {
  [ -n "$(git config user.email)" ] \
    && [ -n "$(git config user.name)" ] \
    && return 0 \
    || true

  >&2 echo "ERROR: Please set the Git user.email and user.name"

  exit_1
}

# ***

git_tag_local_delete () {
  local version_tag="$1"

  if ! git_tag_exists "${version_tag}"; then
    echo "‚úì Missing local tag"

    return
  fi

  git_bump_confirm_delete "${version_tag}" "" \
    || return 0

  echo_or_eval git tag -d "${version_tag}"
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

github_release_delete () {
  local version_tag="$1"

  if ! gh release view "${version_tag}" > /dev/null 2>&1; then
    return
  fi

  # Don't need to prompt: `gh` has its own.
  #
  #  git_bump_confirm_delete "${version_tag}" "GitHub releases" \
  #    || return 1

  gh release delete "${version_tag}"
}

git_tag_remote_delete () {
  local version_tag="$1"
  local remote_name="$2"

  # (lb): I realize there's a less obtuse syntax to delete tags, e.g.,
  #           git push --delete ${remote_name} ${tag_name}
  #       But that syntax might also delete a branch of the same name.
  #       So be :obtuse, and be specific about what's being deleted.
  echo_or_eval git push "${remote_name}" ":refs/tags/${version_tag}"
}

git_tag_remote_push () {
  local version_tag="$1"
  local tag_commit="$2"
  local remote_name="$3"
  local remote_branch="$4"
  local skip_push_branch="$5"

  # We've already verified the remote name is defined locally:
  #
  #   must_remote_exists "${remote_name}"
  #
  # But we haven't attempted to contact the remote until now,
  # so we don't yet know that it's actually reachable/online.
  #
  # - The `git_tag_remote_verify_commit` function, below,
  #   calls git-ls-remote, which contacts the remote server.

  local verify_result

  # Prefix the git_tag_remote_verify_commit output to better
  # distinguish it from other messages.
  printf '%s' '- '

  # Delete remote version tag from target commit.
  # - This makes a network call (via git-ls-remote).
  # - This checks if the same version tag exists on the remote,
  #   and if it's applied to the same target commit or not.
  #   - If tag exists and applied to commit, returns GNUBS_TAG_PRESENT (0).
  #   - If tag exists but applied to a different commit,
  #     prompts user to delete that tag from the remote.
  #   - If tag doesn't exist, returns GNUBS_TAG_ABSENT (1).
  #   - On error, returns GNUBS_FAILED (-1).
  GNUBS_TAG_COMMIT_OBJECT=""
  set +e
  git_tag_remote_verify_commit "${version_tag}" "${remote_name}" "${tag_commit}"
  verify_result=$?
  set -e

  if [ ${verify_result} -eq ${GNUBS_FAILED} ]; then
    >&2 echo "ERROR: git_tag_remote_verify_commit failed"

    exit_1
  elif [ ${verify_result} -eq ${GNUBS_TAG_CONFLICT} ]; then
    git_bump_print_conflict_alert "${version_tag}" "${remote_name}" "${tag_commit}"

    # Returns 0 on 'Y', 1 on 'S', and will exit app on 'N'.
    # - Return 0 so caller doesn't errexit.
    git_bump_confirm_delete "${version_tag}" "${remote_name}" \
      || return 0

    git_tag_remote_delete "${version_tag}" "${remote_name}"

    verify_result=${GNUBS_TAG_ABSENT}
  fi

  # ***

  if ${ACTION_DELETE}; then
    if [ ${verify_result} -eq ${GNUBS_TAG_PRESENT} ]; then
      # Remove the tag. If the remote is on GitHub, this removes the lightweight
      # (non-annotated) release (e.g., from https://github.com/user/repo/releases)
      # that's automatically generated when the tag was initally applied.
      # - At least that's what I've observed: I'm not quite sure how it works,
      #   or where it's documented, just that deleting the tag clears the entry.
      github_release_delete "${version_tag}"

      git_bump_confirm_delete "${version_tag}" "${remote_name}" \
        || return 0

      git_tag_remote_delete "${version_tag}" "${remote_name}"
    fi

    return 0
  elif [ ${verify_result} -eq ${GNUBS_TAG_PRESENT} ]; then
    # The tag is already pushed.
    echo "‚úì Remote already up-to-date"

    return 0
  elif [ ${verify_result} -ne ${GNUBS_TAG_ABSENT} ]; then
    # Impossible path.
    >&2 echo "ERROR: Unexpected verify_result: ${verify_result} (expecting ${GNUBS_TAG_ABSENT})"

    return 1
  fi
  # else, [ ${verify_result} -eq ${GNUBS_TAG_ABSENT} ], so push it.

  # ***

  git_bump_confirm_push "${version_tag}" "${remote_name}" \
    || return 0

  # If user specified "HEAD" <COMMIT>, push that, too.
  # - Otherwise we're tagging the current remote branch HEAD,
  #   so this push would be meaningless (wasted network call).
  # - By pushing to ${remote_branch}, we ensure that user can
  #   work on that branch locally, tag it, and then push both
  #   the branch commit and the tag simultaneously (we don't
  #   require user to push branch themselves before bumping).
  #   - Note that we previously bailed if ${remote_branch} is
  #     not the same as the local branch.
  if ! "${skip_push_branch}"; then
    echo_or_eval git push "${remote_name}" "${tag_commit}:refs/heads/${remote_branch}"

    echo "‚úì Pushed remote branch"
  fi

  # Note that GitHub automatically creates a release for the tag,
  # but it'll be replaced after your CI runs and creates a proper
  # release (well, assuming you have a release workflow tied to a
  # version tag event).
  echo_or_eval git push "${remote_name}" "refs/tags/${version_tag}"

  echo "‚úì Pushed remote tag"
}

# ***

# DEBAR: We could also verify that the remote commit object
# doesn't have "hidden" tags, but it's an unlikely scenario,
# and git-ls-remote is costly (it's a slower network call).
#
# - How you could check: Call `git ls-remote --tag <remote>`,
#   parse results for ${tag_commit}, then examine tag names.
#
#   - Look for version tags, and complain (or fail) if there
#     are more than one version tags, or if the version tag
#     is different from ${version_tag}.
#
#   - We could do this from within the previous function,
#     git_tag_remote_push, e.g., after calling
#     git_tag_remote_verify_commit.
#
# - How you could create the situation: Create a tag, push it,
#   delete it (but not off the remote), create a new version tag
#   at the same commit, and push that tag.
#
#   - Now the remote has two version tags on the same commit.
#
# - This app prevents double-versioning locally in most cases.
#   It'll refuse to run if ${tag_commit} already has a version
#   different than ${version_tag}, except if that ${tag_commit}
#   has a prerelease version, and ${version_tag} is a release.
#   See:
#
#     insist_tag_commit_unversioned_or_same_version_or_dropping_prerelease
#
#   - So the scenario described only happens if the user
#     fails to delete remote tags after deleting locally.
#
# - But it's really not a big deal if there are multiple versions
#   on the same commit. It mostly just looks funny (sloppy).
#
# - Considering all that, and that git-ls-remote is a slower
#   network call, we won't check integrity of tags applied to
#   ${tag_commit} on the remote.
#
#   - But in the call to `git_tag_remote_verify_commit`, we do
#     check the integrity of at least the version tag applied on
#     the remote -- the function fails if the version tag is
#     already applied on the remote, but to a different commit.
#
#     - This is your classic `git push --force` situation,
#       except we don't know which tag is the "correct" tag,
#       be it the local tag, or the remote tag.
#
#     - So we need the user to decide which tag to keep,
#       and which tag to clobber.
#
#   - Another way to reason this:
#     - It's okay to apply more than one version tag to the same commit.
#     - It's not okay to have more than one commit with the same version.
#       - Git won't let this happen in the same repo anyway,
#         but it could happen between two separate repos.
#       - If app sees this, it'll fail to user to resolve the conflict.

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

git_smallest_version_tag () {
  local since_commit="$1"

  # Using --contains will find tags between ${since_commit} and any head
  # (so if you've rebased work after ${since_commit} and abandoned tags
  # in those other lines of work, --contains will find those tags).

  local smallest_patch="$( \
    git tag -l --contains "${since_commit}" "[0-9]*" "v[0-9]*" \
      | command grep -E -e "${GITSMART_RE_VERSPARTS}" \
      | command sort -V \
      | command head -n1
  )"

  # This is *ridonkulous*.
  local smallest_including_alpha="$( \
    git tag -l --contains "${since_commit}" "${smallest_patch}*" "v${smallest_patch}*" \
      | command grep -E -e "${GITSMART_RE_VERSPARTS}" \
      | command grep -E -v "^${smallest_patch}$" \
      | command perl -ne "print if s/${GITSMART_RE_VERSPARTS}/\6, \7, \2.\3.\5\6\7/" \
      | command sed '/^$/d' \
      | command sort -k1,1 -k2,2n \
      | command head -n1 \
      | command sed -E "s/^[^,]*, [^,]*, //"
  )"

  local smallest_version="${smallest_including_alpha}"
  [ -n "${smallest_version}" ] || smallest_version="${smallest_patch}"

  printf "%s" "${smallest_version}"
}

# ***

check_prev_version_lt_later_version () {
  local prev_version="$1"
  local later_version="$2"
  local tag_commit="$3"

  if [ -z "${later_version}" ]; then
    return 0
  fi

  if [ "${prev_version}" = "${later_version}" ]; then
    >&2 echo "ERROR: Version ‚Äú${later_version}‚Äù already exists."

    return 1
  fi

  if is_version_lt_version "${prev_version}" "${later_version}"; then
    return 0
  fi

  >&2 echo "ERROR: Cannot apply version to older commit larger than later version."
  >&2 echo "- Apply version: ‚Äú${prev_version}‚Äù"
  >&2 echo "- Target commit: ‚Äú${tag_commit}‚Äù"
  >&2 echo "- Conlicts with: ‚Äú${later_version}‚Äù (Smallest version after commit)"

  return 1
}

# ***

# WORDS: Per SemVer 2.0.0 doc:
# - A "Normal" version is X.Y.Z form (no prerelease parts), which we use to
#   simplify the comparison (i.e., if X.Y.Z parts don't match, we don't need
#   to compare prerelease parts, which is lots more tedious).
# - A "Version" version (without a qualifier) means full version, whether a
#   Normal version (X.Y.Z) or a Pre-release version (X.Y.Z-*).
# - ALTLY: `man git-config` 'versionsort.suffix' terms: 'base version' and 'suffix'.

# USAGE: Returns 0 if lhs < rhs, or 1 if lhs >= rhs.
is_version_lt_version () {
  local lhs_version="$1"
  local rhs_version="$2"

  if [ "${lhs_version}" = "${rhs_version}" ]; then
    return 1
  fi

  # 'pep440cmp' is optional, but we can do this without it.

  local lhs_normal
  local rhs_normal

  lhs_normal="$(strip_prerelease "${lhs_version}")"
  rhs_normal="$(strip_prerelease "${rhs_version}")"

  # Compare versions without their prerelease parts.
  if [ "${lhs_normal}" != "${rhs_normal}" ]; then
    # The versions don't match at the patch level, so we can compare
    # them without their prerelease parts.
    local smaller_normal="$( \
      echo -e "${lhs_normal}\n${rhs_normal}" \
        | command sort -V \
        | command head -n1
    )"

    if [ "${smaller_normal}" = "${lhs_normal}" ]; then

      return 0
    fi
  else
    # The versions match at the patch level, so compare prerelease parts.
    local smaller_version="$(
      print_smaller_vers_for_same_patch "${lhs_version}" "${rhs_version}"
    )"

    if [ "${smaller_version}" = "${lhs_version}" ]; then

      return 0
    fi
  fi

  return 1
}

# ***

check_prev_version_gt_earlier_version () {
  local prev_version="$1"
  local earlier_version="$2"
  local tag_commit="$3"

  # Not necessary/won't hit, because `check_prev_version_lt_later_version`
  # did it first. But just so you know this case won't happen.
  #
  if [ "${prev_version}" = "${earlier_version}" ]; then
    >&2 echo "ERROR: Version ‚Äú${prev_version}‚Äù already exists."

    return 1
  fi

  if is_version_gt_version "${prev_version}" "${earlier_version}"; then

    return 0
  fi

  >&2 echo "ERROR: Cannot apply version to older commit smaller than earlier version."
  >&2 echo "- Apply version: ‚Äú${prev_version}‚Äù"
  >&2 echo "- Target commit: ‚Äú${tag_commit}‚Äù"
  >&2 echo "- Conlicts with: ‚Äú${earlier_version}‚Äù (Largest version before commit)"

  return 1
}

# ***

# USAGE: Returns 0 if lhs > rhs, or 1 if lhs <= rhs.
is_version_gt_version () {
  local lhs_version="$1"
  local rhs_version="$2"

  if [ "${lhs_version}" = "${rhs_version}" ]; then
    return 1
  fi

  # 'pep440cmp' is optional, but we can do this without it.

  local lhs_normal
  local rhs_normal

  lhs_normal="$(strip_prerelease "${lhs_version}")"
  rhs_normal="$(strip_prerelease "${rhs_version}")"

  # Compare versions without their prerelease parts.
  if [ "${lhs_normal}" != "${rhs_normal}" ]; then
    # The versions don't match at the patch level, so we can compare
    # them without their prerelease parts.
    local smaller_normal="$( \
      echo -e "${lhs_normal}\n${rhs_normal}" \
        | command sort -V \
        | command head -n1
    )"

    if [ "${smaller_normal}" = "${rhs_normal}" ]; then

      return 0
    fi
  else
    # The versions match at the patch level, so compare prerelease parts.
    local smaller_version="$(
      print_smaller_vers_for_same_patch "${lhs_version}" "${rhs_version}"
    )"

    if [ "${smaller_version}" = "${rhs_version}" ]; then

      return 0
    fi
  fi

  return 1
}

# ***

strip_prerelease () {
  local version_full="$1"

  command perl -pe "s/${GITSMART_RE_VERSPARTS}/\2.\3.\5/" <<<"${version_full}"
}

# ***

# Assumes version through patch level matches, so that it can sort by pre-release parts.
print_smaller_vers_for_same_patch () {
  local lhs_version="$1"
  local rhs_version="$2"

  echo -e "${lhs_version}\n${rhs_version}" \
    | command perl -ne "print if s/${GITSMART_RE_VERSPARTS}/\6, \7, \2.\3.\5\6\7/" \
    | command sed '/^$/d' \
    | command sort -k1,1r -k2,2n \
    | command head -n1 \
    | command sed -E "s/^[^,]*, [^,]*, //"
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

insist_tag_commit_unversioned_or_same_version_or_dropping_prerelease () {
  local version_tag="$1"
  local tag_commit="$2"
  local remote_name="$3"
  local remote_branch="$4"

  local refname="$(git_sha_shorten "${tag_commit}")"
  if [ "${remote_name}" != "${BUMP_SKIP_REMOTE}" ]; then
    refname="${remote_name}/${remote_branch}"
  fi

  local existing_tags
  existing_tags="$(git_versions_tagged_for_commit_object "${tag_commit}")"

  if [ -n "${existing_tags}" ]; then
    local num_versions="$(echo "${existing_tags}" | wc -l)"

    if [ ${num_versions} -gt 1 ]; then
      >&2 echo "ERROR: The target commit ‚Äú${refname}‚Äù already has more than one version tag:"
      >&2 echo "${existing_tags}"

      exit_1
    fi

    local commit_version="${existing_tags}"

    # There's one Use Case for allowing two versions on the same commit:
    # - One prerelease, One release.
    # If you have another Use Case, plumb it and PR it, or open an Issue.
    # - Because I'd love to learn of other use cases for multi-versioning.
    if [ "${commit_version}" != "${version_tag}" ]; then
      if is_version_pre_release "${commit_version}" \
        && is_version_normal "${version_tag}" \
        && is_version_gt_version "${version_tag}" "${commit_version}" \
      ; then
        >&2 echo "BWARE: Double-tagging commit: Adding Normal version atop Pre-release"
      else
        >&2 echo "ERROR: The target commit ‚Äú${refname}‚Äù is already version-tagged: ${commit_version}"
        >&2 echo "- Hint: You can use a Normal version atop a Pre-release, but that's it."

        exit_1
      fi
    fi
  fi
}

# ***

is_version_pre_release () {
  local version_full="$1"

  local version_normal
  version_normal="$(strip_prerelease "${version_full}")"

  [ "${version_full}" != "${version_normal}" ]
}

is_version_normal () {
  local version_full="$1"

  local version_normal
  version_normal="$(strip_prerelease "${version_full}")"

  [ "${version_full}" = "${version_normal}" ]
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

git_wip_commit_if_untidy () {
  local wipped=false

  # If nothing is staged, git-commit fails, but we'll check git-status anyway.
  test -n "$(git status --porcelain=v1)" \
    && git add -A \
    && git commit -q --no-verify -m 'PRIVATE: WIP [${CACHE_PROG_NAME}]' > /dev/null \
    && wipped=true \
    || true

  printf "%s" "${wipped}"
}

# ***

git_pop_wip_commit_maybe () {
  local wipped="$1"

  ${wipped} && git reset -q --mixed @~1 || true
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

git_bump_tag_vers_push () {
  # Passed args ($@) from CLI will be passed to and parsed by
  # must_resolve_new_version_tag.

  # Remind user if they're dry-running.
  ${DRY_RUN} && echo "# TEST AHOY! (DRY_RUN=true)" || true

  # ***

  # Insist run from within a Git project.
  git_insist_git_repo || exit_1

  # Create temporary WIP commit if untidy.
  _WIPPED="$(git_wip_commit_if_untidy)"

  # ***

  # Note that git-smart returns the latest version-looking tag.
  # - It's not guaranteed to be SemVer compliant.
  local curr_version="$(git_largest_version_tag)"

  # USYNC: version_tag_environs
  local VERSION_TAG=""
  local ACTION_DELETE=false
  local ACTION_PUSH=false
  local REMOTE_NAME=""
  local TAG_COMMIT=""
  # If version specified, fails if not greater than current version.
  # If bump args specified, fails on args error.
  must_resolve_new_version_tag "${curr_version}" "$@"

  # ***

  local remote_name="${REMOTE_NAME}"

  # Unless skipping remote push, warn if no remote; maybe fetch;
  # and recalculate next version if new version tag was fetched.
  if [ "${remote_name}" != "${BUMP_SKIP_REMOTE}" ]; then
    # Default to the remote tracking branch remote.
    [ -n "${remote_name}" ] || remote_name="$(git_upstream_parse_remote_name)"
    # If no such tracking branch, use sole remote if only one set.
    if [ -z "${remote_name}" ]; then
      if [ -n "$(git remote -v)" ]; then
        local push_remotes
        push_remotes="$(git remote -v | grep -e ' (push)$')"

        local num_remotes
        num_remotes=$(echo "${push_remotes}" | wc -l)

        if [ ${num_remotes} -eq 1 ]; then
          # Just one remote; use it.
          remote_name="$(echo "${push_remotes}" | sed 's/^\([^[:space:]]\+\).*/\1/')"
        else
          # This is the case: [ ${num_remotes} -gt 1 ]
          >&2 echo "ERROR: Branch has no upstream, but more than one remote configured"
          >&2 echo "- Please set a remote tracking branch and try again"
          >&2 echo "  - E.g., if you've already pushed to the remote:"
          >&2 echo "      git branch -u <remote/branch>"
          >&2 echo "  - Or if this is your first push:"
          >&2 echo "      git push -u <remote> <ref>:refs/heads/<branch>"
          >&2 echo "- Failed to consider applying ${VERSION_TAG}"

          exit_1
        fi
      else
        # Seems unnecessary:
        #   >&2 echo "BWARE: There are no remotes. You can only version locally"
        # Skip remote dealings.
        remote_name="${BUMP_SKIP_REMOTE}"
      fi
    fi
  fi

  if [ "${remote_name}" != "${BUMP_SKIP_REMOTE}" ]; then
    # We don't necessarily care if the remote doesn't exist ‚Äî we could still
    # tag the local branch, and then fail on/before the git-push ‚Äî but this
    # also seems like an issue the user should be made to resolve first. If
    # they really don't care, they can re-run the command with "-" as the
    # remote name to skip remote functionality. But really they'll probably
    # want to fix the local repo remote, or fix their bump-version-tags arg.
    must_remote_exists "${remote_name}"

    # Fetch remote at least every hour (network call).
    periodically_fetch "${remote_name}"

    local postfetch_curr_version="$(git_largest_version_tag)"

    if [ "${postfetch_curr_version}" != "${curr_version}" ]; then
      curr_version="${postfetch_curr_version}"

      # We fetched tags from the remote and found a more recent
      # latest tag, so reapply the bump options to the actual
      # latest version.
      must_resolve_new_version_tag "${curr_version}" "$@"
    fi
  fi

  # ***

  # Insist remote/branch HEAD unversioned or matches desired.
  local remote_branch
  if [ "${remote_name}" != "${BUMP_SKIP_REMOTE}" ]; then
    remote_branch="$(print_git_remote_default_branch_name "${remote_name}")" \
      || exit_1

    ${DRY_RUN} && echo "Remote: ${remote_name}/${remote_branch}" || true
  fi

  # ***

  # Suss tag_commit from local_head_sha and remote_head_sha.

  local tag_commit="${TAG_COMMIT}"

  local remote_head_sha
  if [ "${remote_name}" != "${BUMP_SKIP_REMOTE}" ]; then
    remote_head_sha="$(
      git_remote_branch_object_name "${remote_name}" "${remote_branch}"
    )"
  fi

  if [ -z "${tag_commit}" ]; then
    if [ "${remote_name}" != "${BUMP_SKIP_REMOTE}" ]; then
      tag_commit="${remote_head_sha}"
    else
      tag_commit="HEAD"
    fi
  fi

  local local_head_sha="$(git_HEAD_commit_sha)"

  if [ "${tag_commit}" = "HEAD" ]; then
    if [ "${remote_name}" != "${BUMP_SKIP_REMOTE}" ]; then
      # Ensure branch names match (don't let user accidentally tag and
      # push wrong branch to remote).
      local local_branch="$(git_branch_name)"

      if [ "${local_branch}" != "${remote_branch}" ]; then
        >&2 echo "ERROR: Expected the same local and remote branch names"
        >&2 echo "- Not ‚Äú${local_branch}‚Äù (local) and ‚Äú${remote_branch}‚Äù (remote)"

        exit_1
      fi
    fi

    # Optional: git-put-wise scope logic.
    if ! command -v identify_scope_ends_at > /dev/null; then
      tag_commit="${local_head_sha}"
    else
      # Exclude latest commits whose messages start with "PRIVATE: " or
      # "PROTECTED: ". Use case: So you can keep some stuff private to
      # your local repo without needing to maintain a separate feature
      # branch.
      tag_commit="$( \
        identify_scope_ends_at "^${SCOPING_PREFIX}" "^${PRIVATE_PREFIX}" \
      )"
    fi
  fi

  local default_tag_commit="${tag_commit}"

  # ***

  local CURR_VERSION="${curr_version}"

  # Sets CURR_VERSION.
  push_or_delete \
    "${tag_commit}" \
    "${remote_name}" \
    "${remote_branch}" \
    "${local_head_sha}" \
    "${remote_head_sha}"

  if ${ACTION_DELETE} && ${ACTION_PUSH}; then
    ACTION_DELETE=false
    # ACTION_PUSH=false

    tag_commit="${default_tag_commit}"

    # Sets CURR_VERSION.
    push_or_delete \
      "${tag_commit}" \
      "${remote_name}" \
      "${remote_branch}" \
      "${local_head_sha}" \
      "${remote_head_sha}"
  fi

  # ***

  git_pop_wip_commit_maybe "${_WIPPED}"
}

# ***

push_or_delete () {
  local tag_commit="$1"
  local remote_name="$2"
  local remote_branch="$3"
  local local_head_sha="$4"
  local remote_head_sha="$5"

  # SCOPE: Vars. from caller scope:
  #  CURR_VERSION

  local SKIP_PUSH_BRANCH=true

  if ! ${ACTION_DELETE}; then
    # Sets SKIP_PUSH_BRANCH and CURR_VERSION.
    prepare_push \
      "${tag_commit}" \
      "${remote_name}" \
      "${remote_branch}" \
      "${local_head_sha}" \
      "${remote_head_sha}"

    # Tag the local commit (returns immediately if already tagged).
    git_tag_local_add "${VERSION_TAG}" "${tag_commit}" "${CURR_VERSION}"
  else
    # Set tag_commit to tag commit ID, which we pass to remote delete tag
    # so it can check for conflict (not that it really matters on delete,
    # but could be interesting to user).
    tag_commit="$(git_tag_commit_object "${VERSION_TAG}")"
  fi

  if [ "${remote_name}" != "${BUMP_SKIP_REMOTE}" ]; then
    # Delete and/or push the remote tag (and maybe the branch).
    git_tag_remote_push "${VERSION_TAG}" "${tag_commit}" \
      "${remote_name}" "${remote_branch}" "${SKIP_PUSH_BRANCH}"
  fi

  # Delete locally last, so user doesn't abandon remote tag
  # (well, abandon until the next fetch or pull).
  if ${ACTION_DELETE}; then
    git_tag_local_delete "${VERSION_TAG}"
  fi
}

# ***

prepare_push () {
  local tag_commit="$1"
  local remote_name="$2"
  local remote_branch="$3"
  local local_head_sha="$4"
  local remote_head_sha="$5"

  # SCOPE: Vars. seen by caller:
  #  CURR_VERSION=<set below>
  #  SKIP_PUSH_BRANCH=<set here and below>
  SKIP_PUSH_BRANCH=false

  if [ "${remote_name}" != "${BUMP_SKIP_REMOTE}" ]; then
    if [ "${tag_commit}" = "${remote_head_sha}" ]; then
      # Don't need to push this commit, which is remote branch HEAD.
      SKIP_PUSH_BRANCH=true
    fi
  fi

  # *** Normalize the version

  VERSION_TAG="$(normalize_version "${VERSION_TAG}")"

  # *** Verify version order integrity between commits before and commits after

  # Verify tag_commit not versioned, or same as ${VERSION_TAG}.
  # - See also git_versions_tagged_for_commit_object, which finds all
  #   version tags applied to a commit object. Here we identify just
  #   the largest one.
  local commit_version
  commit_version="$(git_largest_version_tag --points-at ${tag_commit})"

  if [ -n "${commit_version}" ]; then
    # We'll compare ${commit_version} and ${VERSION_TAG} after the if-else.
    # - See below:
    #   insist_tag_commit_unversioned_or_same_version_or_dropping_prerelease

    # SCOPE: Var. seen by caller.
    # - So that git_tag_local_add doesn't add same tag again.
    CURR_VERSION="${commit_version}"
  else
    if [ "${tag_commit}" = "${local_head_sha}" ]; then
      insist_next_version_gt_curr_version "${VERSION_TAG}" "${CURR_VERSION}" "${tag_commit}"
    else
      # Means we're tagging an old commit.
      # MEH: I don't know why we support this. Maybe I just wanted to
      #      write hundreds of lines of more code to maintain.
      # - Seems like a weird use case to support: Tagging old commit.

      local latest_smallest_version
      # This includes ${tag_commit} tags, but we checked that case
      # earlier, so we know ${tag_commit} is not versioned here.
      latest_smallest_version="$(git_smallest_version_tag "${tag_commit}")"
      if ! check_prev_version_lt_later_version \
        "${VERSION_TAG}" "${latest_smallest_version}" "${tag_commit}" \
      ; then

        exit_1
      fi

      # Note the --no-contains is more inclusive than finding tags from the
      # first commit (git rev-list --max-parents=0 HEAD) through ${tag_commit}.
      # The --no-contains will look through those commits, but it also includes
      # any other line of work that doesn't contain ${tag_commit}.
      local earlier_largest_version="$(git_largest_version_tag --no-contains ${tag_commit})"
      if ! check_prev_version_gt_earlier_version \
        "${VERSION_TAG}" "${earlier_largest_version}" "${tag_commit}" \
      ; then

        exit_1
      fi
    fi
  fi

  # This is similar to the [ "${commit_version}" != "${VERSION_TAG}" ] check
  # above, but more robust. It checks no more than one tag already applied,
  # and there is a pre-existing tag, verifies new tag > old tag, and that
  # the new tag is normaling a pre-release version.
  insist_tag_commit_unversioned_or_same_version_or_dropping_prerelease \
    "${VERSION_TAG}" "${tag_commit}" "${remote_name}" "${remote_branch}"

  # *** Verify version order integrity between local and remote repos

  if [ "${remote_name}" != "${BUMP_SKIP_REMOTE}" ]; then
    if ! ${SKIP_PUSH_BRANCH}; then
      # We know ${tag_commit} != ${remote_head_sha} because ! ${SKIP_PUSH_BRANCH}.

      # Check if the local branch has more commits than the remote branch.
      if ! git merge-base --is-ancestor ${tag_commit} ${remote_head_sha}; then
        # Local ahead of remote.
        if ! git merge-base --is-ancestor ${remote_head_sha} ${tag_commit}; then
          >&2 echo "ERROR: Remote branch HEAD and target commit not in same branch"

          exit_1
        fi
      fi
      # else, remote ahead of local. Means we're tagging an old commit.
    fi
    # else, means we're not moving remote branch HEAD.
  fi
}

# ***

# Normalize the version otherwise a tool such as poetry-dynamic-versioning
# might impress upon the build a version slightly different than what you
# set. E.g., it'll change 1.1.1-a-1 to 1.1.1-a.1.
#
# dunamai version styles:
# - PEP 440
#   https://www.python.org/dev/peps/pep-0440
# - Semantic Versioning
#   https://semver.org)
# - Haskell Package Versioning Policy
#   https://pvp.haskell.org
#
# https://github.com/mtkennerly/poetry-dynamic-versioning
# https://github.com/mtkennerly/dunamai

normalize_version () {
  local orig_version="$1"

  # `dunamai from git --style`: [--style {pep440,semver,pvp}]
  local normal_style="semver"

  if [ -f "$(git_project_root)/pyproject.toml" ]; then
    normal_style="pep440"
  fi

  local normal_vers
  normal_vers="$(normalize_version_with_style "${VERSION_TAG}" "${normal_style}")"

  # Unnecessary double-check (before adding dunamai and PEP440 support, this
  # script was the SemVer style enforcer; but now dunamai is in charge, so
  # this check should never fail, and is being included mostly out of
  # curiosity, but also as an excuse not to delete the callee).
  if [ "${normal_style}" = "semver" ] \
    && (! ${ACTION_DELETE} || ${ACTION_PUSH}) \
  ; then
    insist_new_version_semver_compliant "${VERSION_TAG}"
  fi

  if [ "${normal_vers}" != "${VERSION_TAG}" ]; then
    if git_bump_confirm_normalize "${VERSION_TAG}" "${normal_vers}" "${normal_style}"; then
      VERSION_TAG="${normal_vers}"
    fi
  fi

  printf "%s" "${VERSION_TAG}"
}

normalize_version_with_style () {
  local orig_version="$1"
  local normal_style="$2"

  local prefixed_version="${orig_version}"
  if [ "${orig_version}" = "${orig_version#v}" ]; then
    prefixed_version="v${orig_version}"
  fi

  local temp_dir="$(mktemp -d /tmp/$(basename $0)-XXXXXXX)"
  [ ! -d "${temp_dir}" ] \
    && >&2 echo "ERROR: \`mktemp\` failed" \
    && exit_1 \
    || true

  cd "${temp_dir}"

  git init . -q
  # When run from CI, Git user default unset, so use fake vals.
  git config user.email foo
  git config user.name foo
  touch foo
  git add foo
  # When run from CI, Git user unset, so use placeholder.
  git commit -m foo -q
  git tag "${prefixed_version}"

  # The two styles we support:
  #  dunamai from git --style semver
  #  dunamai from git --style pep440
  dunamai from git --style "${normal_style}"

  cd - > /dev/null

  # DEV: Uncomment to leave temp dir:
  #
  #   >&2 echo "${temp_dir}"
  #   exit_1

  /bin/rm -rf "${temp_dir}"
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

_NORMAL_EXIT=false

exit_1 () {
  _NORMAL_EXIT=true

  exit 1
}

exit_0 () {
  _NORMAL_EXIT=true

  exit 0
}

_WIPPED=false

exit_cleanup () {
  git_pop_wip_commit_maybe "${_WIPPED}"

  if ! ${_NORMAL_EXIT}; then
    # Dev: Unexpected error path occurred, you might wanna graceify.
    >&2 echo "ALERT: ${PROG_NAME} exited abnormally!"
    >&2 echo "- Hint: Enable \`set -x\` and run again..."
  fi
}
trap exit_cleanup EXIT

# ***

main () {
  # Using errexit makes for a more robust script, and is esp. important
  # for unattended CI runs.
  set -e

  source_deps "${BASH_SOURCE[0]}" || exit_1

  git_bump_tag_vers_push "$@"
}

if [ "$0" = "${BASH_SOURCE[0]}" ]; then
  main "${@}"
fi

# Unhook exit_cleanup.
trap - EXIT

